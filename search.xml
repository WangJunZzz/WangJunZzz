<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小本本]]></title>
    <url>%2F2019%2F10%2F29%2F%E5%B0%8F%E6%9C%AC%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[请输入密码以阅读这篇私密文章。 027d3358725932e43fcaad2bacaa8d82609ba8f0f580b64194da872d424fbee242640589e9904a3d050078db30da798b6a838b81a337f66b256bfdbede539d0e4a876e14c1dd6b64b4cc722df6f92b3290433e3dfdc73a4fb384ac5c69aebe482361b290a76d188dc73ed18c1528cbd0dff559011ee866a8e88be0fdea762757f7d768a7fdb908ed7592906c46198d71441191acd0bc38576122710db146d94febb63d7efe09701c57b595215668a4e595253d9d2915685b2479fd93c5f8e7587ba04e2c5c675596b0a938f91bb80f5cd3b7c685c8f036c09e8f41124154fedaf0366da2b7b1cc0f9f51739b3383475e0a40672c962a8d49700b5f4fea13c6499c8e4168cbe349d464b427f71c739085c53a0dbbd19af91729d657eb205c56381db2e7a915f788cf1270e1d74e09556f88f6d9ceaaff6ea25070db3f60507c584408fd442db6ecc533ab450be8b2db7da96f360411be7c1a60585164b53b5749879ddca813bce7001deaa3f34ea106015494324298ddce044174c4ed0d2707156ff8937c87b5a03e014b8a50c7617569]]></content>
  </entry>
  <entry>
    <title><![CDATA[第一步Docker书]]></title>
    <url>%2F2019%2F10%2F29%2F%E4%B9%A6%E7%B1%8D%2F%E7%AC%AC%E4%B8%80%E6%AD%A5Docker%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[容器 容器是直接运行在操作系统内核之上的用户空间。容器不仅仅是一个单纯的运行环境，在自己的权限范围内，容器更像是一个完整的宿主机。容器有独立的网路和存储栈，还拥有自己的资源管理能力，使得同一台宿主机中的多个容器可以友好的共存。 Docker Docker是一个能够把开发得应用程序自动部署到容器得开源引擎。Docker镜像是构建docker世界得基石，用户基于镜像来运行自己得容器。镜像是Docker生命周期中得构建或者打包阶段，而容器是启动或者执行阶段。 Docker应用场景 加速本地开发和构建流程，使其更加高效，轻量化。 高性能，超大规模得宿主机部署。 Docker 命令123456789101112131415161718192021222324252627282930# 拉取镜像docker pull# 查找镜像docker search images_name# 运行一个容器docker run -it --name docker_name ubuntu /bin/bash# 启动容器docker start docker_name# 停止容器docker stop docker_name# 重启容器docker restart docker_name# 查看所有容器docker ps# 附着到容器[如果推出容器得shell，容器会停止]docker attach docker_name# 查看日志docker logs docker_name# 统计容器信息docker stats# 进入容器docker exec -it docker_name /bin/bash# 自动重启容器docker run --name docker_name --restart=always ubuntu /bin/bash# 删除容器docker rm docker_name# 删除镜像docker rmi docker_image# 查看镜像docker images Dockerfile构建镜像指令 FROM 指定基础镜像 1FROM ubuntu:14.04 CMD 用于指定一个容器启动时要运行得命令，有点类似RUN,只是run指令是指在镜像构建是要运行得命令。docker run 命令可以覆盖CMD指令。 1CMD ["yum","install","-y","nginx"] ENTRYPOINT 和CMD指令很相似，执行cmd指令得时候docker run命令会覆盖，但是entrypoint不会，docker run 命令行中得参数都会被当作参数传递给entrypoint指令中指定得命令。 1ENTRYPOINT ["/usr/sbin/nginx","-g","daemon off"] WORKDIR 指定容器内部工作目录，entrypoint和cmd指令在该目录下执行。 1WORKDIR /opt/webapp ENV 设置环境变量 12#docker build -t supback --build-arg env="Development" .ENV ASPNETCORE_ENVIRONMENT=$env USER 指定镜像以什么样得用户去运行，默认root 12USER userUSER uid:group VOLUME 挂载卷 1VOLUME ["/data"] ADD 12# wangjunzzz仓库名，static_web镜像名，v1 标签 --no-cache 不使用缓存docker build --no-cache -t="wangjunzzz/static_web:v1"]]></content>
  </entry>
  <entry>
    <title><![CDATA[高性能Msql(第三版)]]></title>
    <url>%2F2019%2F10%2F24%2F%E4%B9%A6%E7%B1%8D%2F%E9%AB%98%E6%80%A7%E8%83%BDMsql-%E7%AC%AC%E4%B8%89%E7%89%88%2F</url>
    <content type="text"><![CDATA[Mysql逻辑架构 每个客户端连接都会在服务器进程种拥有一个线程,这个连接的查询只会在这个单独的线程中执行，改线程只能轮流在某个CPU核心或者CPU中运行。 事务123456START TRANSACTION;-- 超出长度UPDATE `testlimit` b SET b.`IsDelete`="4515151515154156165165161651651";UPDATE `user` a SET a.`Name`='wangjun';SELECT * FROM `user`;ROLLBACK; 原子性 一个事务必须被视为一个不可分割得最小工作单元，整个事务中得所有操作要么全部成功，要么全部失败回滚，对于一个事务来讲，不可能只执行其中得一部分操作，这就是事务得原子性。 一致性 数据库总是从一个一致性得状态转换到另外一个一致性得状态。 隔离性 通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见。 持久性 一旦事务提交，则其所做的修改就会永久保存到数据库中。 四种隔离级别Read Uncommitted(未提交读) 在Read Uncommitted级别，事务中的修改，即时没有提交，对其他事务也都是可见的。事务可以读取为提交的数据，也被称为脏读(Dirty Read) Read Committed(提交读) 大多数数据系统默认的隔离级别都是Read Committed(Mysql不是)。Read Committed满足前面提到的隔离性的简单定义：一个事务开始时，只能看见已经提交的事务所做的修改。这个级别有时候也叫不可以重复读(Nonrepeatable Read) Repeatable Read(可重复读，Mysql的默认事务隔离级别) 解决了脏读的问题，保证在同一个事务中多次读取同样的记录的结果是一致的。该级别保证了在同一个事务中多次读取同样的记录结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读的问题。所谓幻读，当某个事务在读物某个范围内的记录时，另外一个事务由在该范围内插入了新的纪录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDb和XtraDb存储引擎通过多版本并发控制解决了幻读的问题。 Serializable(可串行化) 最高级别，通过强制事务串行执行，避免了前面的幻读，简单来说，Serializable会在读取的没一行数据上加上锁，所以可能倒是大量的超时和锁争用的问题。 锁 读写锁，在处理并发读或者写时，可以通过实现一个由2中类型的锁组成的锁系统来解决问题，这2中类型的锁通常被称为共享锁和排他锁，也叫读锁和写锁。锁粒度：表锁(开销最小的锁)，行级锁(开销最大的锁)死锁是指2个或者多个事务在同一个资源上相互占用，并且请求锁定对方占用的资源，从而导致恶性循环的现象。]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.Net Core GRpc]]></title>
    <url>%2F2019%2F10%2F22%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FGRpc%2F</url>
    <content type="text"><![CDATA[.Net Core GRpc gRPC 是一种与语言无关的高性能远程过程调用 (RPC) 框架。 现代高性能轻量级 RPC 框架。 协定优先 API 开发，默认使用协议缓冲区，允许与语言无关的实现。 可用于多种语言的工具，以生成强类型服务器和客户端。 支持客户端、服务器和双向流式处理调用。 使用 Protobuf 二进制序列化减少对网络的使用。 使用GRpc,请先了解Protocol buffer 语法. Protobuf3 语法-中文版 官网文档 GRpc 的数据交互方式1. Unary RPCs，一次请求，一次返回，没有流，123//这是最常用的方式：rpc SayHello(HelloRequest) returns (HelloResponse)&#123;&#125; 2. Server streaming RPCs，客户端发送单次请求，服务端会返回一连串的数据。123//比如服务端向客户端推送站内即时消息：rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse)&#123;&#125; 3. Client streaming RPCs，客户端会发送一连串的数据到服务端，服务端返回单次数据.123//比如发送实时日志：rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) &#123;&#125; 4. Bidirectional streaming RPCs，双向流，两边各自会发送一连串的数据。123//比如实时语音通话以及一些游戏场景中：rpc BidiHello(stream HelloRequest) returns (stream HelloResponse)&#123;&#125; 创建GRpc服务 Protos目录下添加 OrderGrpcServer.proto 1234567891011121314151617181920212223242526272829// 使用proto3语法，不写这个默认使用proto2语法syntax = "proto3"; // 指定C#命名空间option csharp_namespace = "GrpcService.Order";// 包名package Order;// 定义一个grpc 服务service OrderGrpcService &#123; // 定义一个新增订单的方法 rpc AddOrder (OrderRequest) returns (HelloReply);&#125;// 定义AddOrder请求参数// int32 字段类型，id 字段名称，1 字段标识号（用来在消息的二进制格式中识别各个字段的）message OrderRequest&#123; int32 id = 1; string name = 2; double price = 3; string Remark = 4;&#125;//定义AddOrder返回值message OrderResponse&#123; int32 id = 1; int32 isSuccess = 2;&#125; 修改项目的xx.csproj 1234&lt;ItemGroup&gt; //GrpcServices = server 服务端，还有对于的Client &lt;Protobuf Include="Protos\OrderGrpcServer.proto" GrpcServices="Server" /&gt;&lt;/ItemGroup&gt; 编译之后会在项目下生成2个cs文件 实现服务 创建客户端(我这里创建了一个控制台应用程序) 1234// 添加Nuget包Grpc.Net.ClientGoogle.ProtobufGrpc.Tools 把服务端的Protos赋值到客户端项目中，并且修改xx.csporj文件 调用 1234567891011121314static void Main(string[] args)&#123; var channel = GrpcChannel.ForAddress("https://localhost:5001"); var client = new OrderGrpcService.OrderGrpcServiceClient(channel); var response = client.AddOrder(new OrderRequest &#123; Id = 11, Name = "98k", Price = 556, Remark = "测试" &#125;); Console.WriteLine(response); Console.ReadKey();&#125; 示例代码]]></content>
      <tags>
        <tag>微服务架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23种设计模式]]></title>
    <url>%2F2019%2F09%2F30%2Fcsharp%2F23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Source 前言面向对象设计模式通常以类或者对象的描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类或者对象。设计模式能使不稳定依赖于相对稳定，具体依赖相对抽象，避免引起麻烦的紧耦合，以增强软件设计面对适应变化的能力。 六大原则 单一职责原则：如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能，告诉我们不要破坏继承体系。 依赖倒置原则：面向接口编程。 接口隔离原则：设计接口的时候要精简单一 迪米特原则：降低类与类之间的耦合。 开闭原则：要对扩展开放，对修改关闭。 创建型单件模式(Singleton Pattern) 在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。保证一个类仅有一个实例，并提供一个访问它的全局访问点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 单线程实现singletonnamespace Singleton_Pattern&#123; public class SingleThreadSingleton &#123; private static SingleThreadSingleton instance = null; // 构造方法让其private,这就堵死了外界利用new创建此类实例的可能 private SingleThreadSingleton() &#123; &#125; public static SingleThreadSingleton Instance &#123; get &#123; if (instance == null) &#123; instance=new SingleThreadSingleton(); &#125; return instance; &#125; &#125; public void Print() &#123; Console.WriteLine("hello singletion!!!"); &#125; &#125;&#125;// 多线程实现singletonnamespace Singleton_Pattern&#123; public class MultiThreadSingleton &#123; private static volatile MultiThreadSingleton instance = null; private static object lockHelper = new object(); private MultiThreadSingleton() &#123; &#125; public static MultiThreadSingleton Instance &#123; get &#123; if (instance == null) &#123; lock (lockHelper) &#123; if (instance == null) &#123; instance=new MultiThreadSingleton(); &#125; &#125; &#125; return instance; &#125; &#125; public void Print() &#123; Console.WriteLine("hello singletion!!!"); &#125; &#125;&#125; 单例模式和静态方法类的区别（1）代码结构上 单例模式可以有非静态方法和成员的，而且只要获得了实例就可以去调用； 静态方法类通常来说全是静态方法，如果有非静态方法，是不能直接调用的。 （2）编程思想上 单例模式是普通的类，只不过它是有一个实例而已，符合JAVA面向对象的思想； 静态方法类通常又称为工具类，它更像是面向过程的一个函数集。 （3）特性上 单例模式符合所有面向对象的特性，可以去继承类、可以实现接口、可以被继承、方法可以被重写、可以用于多态（不 同实现）； 而静态方法类不能。 （4）生命周期上 单例模式可以延迟初始化，并且一直到运行结束才会被回收； 静态方法类在第一次使用时就会被加载，执行完静态方法后就会被回收，如果频繁调用会导致频繁地初始化和释放。 （5）实例化上 单例模式需要进行实例化（通过静态方法中的new）； 静态方法类不需要实例化，可以直接调用。 （6）内存占用上 单例模式调用哪个方法，就载入哪个方法，但是它需要长时间地维护一个对象； 静态方法类需要把所有静态方法都载入内存，不管你用不用。 （7）线程与共享 单例模式的多线程控制很方便，适合维护或者共享一些配置状态信息； 静态方法类的多线程控制则非常糟糕 工厂方法模式（Factory Method) 工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 工厂方法模式包含如下角色： Product：抽象产品 ConcreteProduct：具体产品 Factory：抽象工厂 ConcreteFactory：具体工厂场景有这么一个需求：XX系统需要支持对数据库中的员工薪资进行导出，并且支持多种格式如：HTML、CSV、PDF等，每种格式导出的结构有所不同，比如：财务跟其他人对导出薪资的HTML格式要求可能会不一样，因为财务可能需要特定的格式方便核算或其他用途。如果使用简单工厂模式，则工厂类必定过于臃肿。因为简单工厂模式只有一个工厂类，它需要处理所有的创建的逻辑。假如以上需求暂时只支持3种导出的格式以及2种导出的结构，那工厂类则需要6个if else来创建6种不同的类型. 抽象工厂（ExportFactory）角色：担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。 具体工厂（ExportHtmlFactory、ExportPdfFactory）角色：担任这个角色的是实现了抽象工厂接口的具体类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类（如：ExportStandardHtmlFile）。 抽象导出（ExportFile）角色：工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。 具体导出（ExportStandardHtmlFile等）角色：这个角色实现了抽象导出（ExportFile）角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。 Code Soucre参考-博客园 抽象工厂（Abstract Factory）建造者模式(Builder)原型模式(Prototype)结构型适配器模式（Adapter Pattern)桥接模式（Bridge Pattern)装饰模式(Decorator Pattern)组合模式(Composite Pattern)外观模式（Facade Pattern)享元模式(Flyweight Pattern)代理模式(Proxy Pattern)行为型模板方法(Template Method)命令模式(Command Pattern)迭代器模式(Iterator Pattern)观察者模式(Observer Pattern）解释器模式(Interpreter Pattern)中介者模式(Mediator Pattern)职责链模式(Chain of Responsibility Pattern)备忘录模式(Memento Pattern)策略模式(Strategy Pattern)访问者模式(Visitor Pattern)状态模式(State Pattern)参考-Design-Pattern参考-Graphic Design Patterns]]></content>
  </entry>
  <entry>
    <title><![CDATA[读微服务设计]]></title>
    <url>%2F2019%2F09%2F26%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F%E8%AF%BB%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[请输入密码以阅读这篇私密文章。 0fb06ff780db0d4550f025ff03cae573625eb3e7fa33ff6e25e03d94e3f218cb56c126f781a4bd11a6b249b7f4c1503fbc615f63d009ae48fd1a3dcc45d6c8091944c88d83408220391223243f17d8061a14154601828a5a69b4685c7bb2748d420ab72abdf321a7acbd5f3d585d71d8078b55e56fd36999cba3d4b6916e96604524ab59cce12a5c95a50d6c4f0f79c6c48c6a8c51fa30167310decee5f93e761f8d0554f97ad42b0f02f7dd44fbac59f6e45145066e6642f460dc8d30a83fc79cc757616fd797d4218e7b20d4b41940cc3198a09689e29635245347af9cd65e2fbdbd00aabdd3dbe9d40528a0ab475cfbc3a83ea09d6a2838a7c28f240428e7ef7c3b56e04ec5a234c5afb721220c12d480c196a293b7ede9fa9f8f85925ffa0d1e6e57debacfa9f70a5674281bca4ba78d6e9abb59f933889190e8fa7a0731be93a95801d35b759605ec65f6f3d1cfe23c86856f31efe204a866caaaef79dd720924d9a4fcb495d597b881e802d20ae30ea5096169318a15521034d22ae4503b469a94ad5ad2a059968ec1dc878fd481f750435d4d624c785843947007eed78d901afbd7c77f3e228940c4fc4d9d6e5a7ee74b77fd273cd084b807eb2b7e8d60427970b8b765512b17cdef6f8fb3134ddd51282ee16a5c06ae71f38c913e9a7fd1a24d510519370e6367bec9975806feef05edc3feeaae7e4ac1f1374c77c09f17182a026b2a20886f8ea427380040bd399531228d6bd8ceb01d8a866a104c916b02aef21961bd5b46eacbef24fdc380a150872203daba2f26e47d8b167f17d337c4477ed54d6c87c3a60a0154d57ef43beb022e84195eed5177817fe7f8f36d72b4ffa94363129398bc20772286315b945188e64db5fc189a3a7d7d92a007604a40300e6900b5f7ff53c59b6a3f61091781ff32b16d8e0879ef32335b5043672056ff7cca071bc6b85a13666d46608587cd651cd7e09055cf4cbb6dfec4a20b7970d66b239dd208ce504a25678427fbc1c2ab0b98a0a9cd804fd140ee473e43fa00fb2b53e05bc4a0fb00704383404d8a5b223a8d707f7b40dab214b6267f2b41399cd90b46a31c04c72a7a2c13ac8dbbd1da8e222873991c2af29b5f53a32bd2a214217553caf3e4453bb875bb66d77617ddaafd71c18fd9de696ea2099f473fb3b18fb8630aa4813cbb4179641cda567d63878cfd86103d243131fc5497cb8a22fee81703032913d76719bf7a2b674f87d16a809b165d9330349ccef052cf9279f4e30b00c31b6a65117d7ca970b09397867d7ae9c59a1134cc72ffeff37b83b674e461c2a08b2cc05c696b198703ee8231151be57d825e7089cc22b35254c2a6602e86ecd0f0935c71139d74746e96e29c5f1d548820f96f64e067a83bdc95066d3ac9fc084ebd7c6ccaa0ebb2b467471ce41e91b6faf1e1e3647292d4c1259fdab7a5cdae30e7f62abb0c74741763932f020d83439e7b79087ee3ee210662bf48700be653e5d9f9a2c5f9b5e049960d13557861d793dc5a9f9ce3e67ba24272adcf922fc65646f779ca1474404857f3c4866ce0f2c176e80655c9b24efbf86efd1d3c8971ab087783481adce8ae3ace19f1c5a34bbce03fb626464e55f50f57cee5d5c12b7122bfe96b458dec6bf4c1c86db6dde535bf87c66df60c5d02085e148cb201fbfc9a0df461cf1fbdafbd69ee4a9db418ca1e84d9de8d66b46223cc8b68345d8ed0b35456132fae1fcb231e9b950e9922e464054b7eb5ddd662417d63c68e741a188134fbc0b79bdf]]></content>
  </entry>
  <entry>
    <title><![CDATA[微服务架构]]></title>
    <url>%2F2019%2F09%2F23%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[微服务架构图 配置中心背景随着业务的发展、微服务架构的升级，服务的数量、程序的配置日益增多（各种微服务、各种服务器地址、各种参数），传统的配置文件方式和数据库的方式已无法满足开发人员对配置管理的要求： 安全性：配置跟随源代码保存在代码库中，容易造成配置泄漏； 时效性：修改配置，需要重启服务才能生效； 局限性：无法支持动态调整：例如日志开关、功能开关； 因此，我们需要配置中心来统一管理配置！把业务开发者从复杂以及繁琐的配置中解脱出来，只需专注于业务代码本身，从而能够显著提升开发以及运维效率。同时将配置和发布包解藕也进一步提升发布的成功率。 简介Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。 Features统一管理不同环境、不同集群的配置 Apollo提供了一个统一界面集中式管理不同环境（environment）、不同集群（cluster）、不同命名空间（namespace）的配置。 同一份代码部署在不同的集群，可以有不同的配置，比如zk的地址等。 通过命名空间（namespace）可以很方便的支持多个不同应用共享同一份配置，同时还允许应用对共享的配置进行覆盖。配置修改实时生效（热发布） 用户在Apollo修改完配置并发布后，客户端能实时（1秒）接收到最新的配置，并通知到应用程序。灰度发布 支持配置的灰度发布，比如点了发布后，只对部分应用实例生效，等观察一段时间没问题后再推给所有应用实例。 携程Apollo再.Net FrameWork上的使用- 新建一个.Net Framework4.7.2的项目 - 添加Com.Ctrip.Framework.Apollo.ConfigurationManager包引用 - 再Web.config的appSettings目录下添加12&lt;add key="Apollo.AppId" value="framework.web" /&gt;&lt;add key="Apollo.MetaServer" value="http://192.168.19.48:8080/" /&gt; - 获取配置文件1234// ApolloConfigurationManager 不过这个是过时的IConfig config = await ApolloConfigurationManager.GetAppConfig();// 获取apollo配置好的连接字符串return config.GetProperty("ConnectionStrings", string.Empty); 携程Apollo再.NetCore2.x上的使用- 新建一个.NetCore2.2项目 - 添加Com.Ctrip.Framework.Apollo.Configuration包引用 - 配置appsettings.json1234567891011&#123; "apollo": &#123; "AppId": "fanyouvip.com" &#125;&#125;// appsettings.development.json&#123; "apollo": &#123; "MetaServer": "http://192.168.19.48:8080" &#125;&#125; - 在Program-&gt;Main函数中添加123456789public static IWebHostBuilder CreateWebHostBuilder(string[] args)&#123; return WebHost.CreateDefaultBuilder(args) .ConfigureAppConfiguration(builder =&gt; builder .AddApollo(builder.Build().GetSection("apollo")) //.AddNamespace("fanyou") // 命名空间 .AddDefault()) .UseStartup&lt;Startup&gt;();&#125; 使用方式一(注入IConfiguration)：12345678910111213141516[Route("api/[controller]")][ApiController]public class ValuesController : ControllerBase&#123; private readonly IConfiguration configuration; public ValuesController(IConfiguration config) &#123; configuration = config; &#125; // GET api/values [HttpGet] public string Get() &#123; return configuration["Test"].ToString(); &#125;&#125; 使用方式二(POCO):- 添加Tuhu.Extensions.Configuration.ValueBinder.Json包引用1234567891011121314151617181920// 在apollo中配置文件是Json格式。项目中建立对于的实体services.ConfigureJsonValue&lt;ConfigMsg&gt;(Configuration.GetSection("Test"));// 获取配置文件信息[Route("api/[controller]")][ApiController]public class ValuesController : ControllerBase&#123; private IOptions&lt;ConfigMsg&gt; config; public ValuesController(IOptions&lt;ConfigMsg&gt; configMsg) &#123; config = configMsg.Value; &#125; [HttpGet] public int Get() &#123; return config.request_timeout; &#125;&#125; Source CodeApollo GithubDevelopor Guide API网关阿里云API网关文档 阿里云API 网关为您提供完整的 API 托管服务，辅助用户将能力、服务、数据以 API 的形式开放给合作伴。 阿里云API 网关提供防攻击、防重放、请求加密、身份认证、权限管理、流量控制等多重手段保证 API 全，降低 API 开放风险。 提供 API 定义、测试、发布、下线等全生命周期管理，并生成 SDK、API 说明文档，提升 API 管理、迭代效率。 提供便捷的监控、报警、分析、API 市场等运维、运营工具，降低 API 运营、维护成本。请求签名说明文档名词解释【必选】X-Ca-Key：AppKey 【必选】X-Ca-Signature：签名字符串 【可选】X-Ca-Timestamp：API 调用者传递时间戳，值为当前时间的毫秒数，也就是从1970 年1月1日起至今的时间转换为毫秒，时间戳有效时间为15分钟 【可选】X-Ca-Nonce：API 调用者生成的 UUID，结合时间戳防重放 【可选】Content-MD5 当请求 Body 非 Form 表单时，可以计算 Body 的 MD5 值传递给云网 关进行 Body MD5 校验 【可选】X-Ca-Stage请求 API 所属 Stage，目前仅支持 TEST 、PRE 和 RELEASE，默认 RELEASE，若您调用的 API 不在线上环境，请一定要指定该参数的值，否则会报 URL 错误Vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# npm install aliyun-api-gateway -S# 在main.js中const Client = require(&apos;aliyun-api-gateway&apos;).Client;const client = new Client(&apos;appkey&apos;, &apos;appsecret&apos;);Vue.prototype.client = client# GETlet opts = &#123; headers: &#123; &quot;content-type&quot;: &quot;application/json; charset=UTF-8&quot;, &quot;X-Ca-Stage&quot;: this.env &#125;&#125;;this.client .get( &quot;http://api.permit.fanyouvip.com/api/Public/Role/xx/xx&quot;, opts ) .then(e =&gt; &#123; console.log(e); &#125;) .catch(err =&gt; &#123; console.log(err); console.log(err.code); &#125;);# POSTlet opts = &#123; headers: &#123; &quot;content-type&quot;: &quot;application/json; charset=UTF-8&quot;, &quot;X-Ca-Stage&quot;: this.env &#125;, data: &#123; userName: &quot;admin&quot;, password: &quot;123&quot;, systemId: &quot;e92983fd6e4c4f598b1e7dfb9d636501&quot; &#125;&#125;;this.client .post(&quot;http://api.permit.fanyouvip.com/api/Public/Login&quot;, opts) .then(res =&gt; &#123; console.log(res); &#125;) .catch(err =&gt; &#123; console.log(err); console.log(err.code); &#125;);&#125; 在Vue中有一个小问题，需要注释调HTTPX中的一段代码，请参考。 .Net Core 2.x 整理了一下阿里云官网提供的SDK文档，发布到私有的Nuget服务器上。 安装 Fairhr.ApiGetWay 在StartUp -&gt; ConfigureServices 12345678910111213141516171819services.AddFarihrGetWay(options =&gt;&#123; options.AppKey = "AppKey"; options.AppSecret = "AppSecret"; // api网关地址 options.Host = "api网关地址"; // 配置环境变量 options.Environment = "TEST&#125;);// 调用apistring result = string.Empty;using (HttpWebResponse response = HttpCoreUtil.HttpGet("/Social/Policy/repair/month/2341"))&#123; Stream st = response.GetResponseStream(); StreamReader reader = new StreamReader(st, Encoding.GetEncoding("utf-8"); result = reader.ReadToEnd();&#125; .Net Framework 整理了一下阿里云官网提供的SDK文档，发布到私有的Nuget服务器上。 安装 Fairhr.ApiGetWay 1234567string result = string.Empty;using (HttpWebResponse response = HttpFrameWorkUtil.HttpGet("api网关地址", Path, "AppKey","AppSecret"))&#123; Stream st = response.GetResponseStream(); StreamReader reader = new StreamReader(st, Encoding.GetEncoding("utf-); result = reader.ReadToEnd().ToString();&#125; 注意 Header 部分。其中 X-Ca开头的均为网关返回(在 Header 中获得 X-Ca-Error-Message 可以基本明确报错原因，而 X-Ca-Request-Id 可以用于提供给这边的支持人员，供支持人员搜索日志)。 1234567X-Ca-Request-Id: 7AD052CB-EE8B-4DFD-BBAF-EFB340E0A5AF //请求唯一ID，请求一旦进入API网关应用后，API网关就会生成请求ID并通过响应头返回给客户端.//建议客户端与后端服务都记录此请求ID，可用于问题排查与跟踪X-Ca-Error-Message: Invalid Url //API网关返回的错误消息，当请求出现错误时API网关会通过响应头将错误消息返回给客户端X-Ca-Debug-Info: &#123;"ServiceLatency":0,"TotalLatency":2&#125; //当打开Debug模式后会返回Debug信息，此信息后期可能会有变更，仅用做联调阶段参考 返回值为空。（HTTP/HTTPS 请求的返回结果有 HttpCode、Header、Body 三部分。当请求报错时，由于没有进入业务逻辑，所以返回的 Body 可能为空，表现为“返回值为空”，但实际上，重要信息都在 Header 里面。） 服务注册和服务发现新建项目 Install-Package OcelotInstall-Package Ocelot.Provider.Consul 添加Ocelot.json 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; "ReRoutes": [ &#123; "DownstreamPathTemplate": "/&#123;url&#125;", "DownstreamScheme": "http", "DownstreamHostAndPorts": [ &#123; "Host": "localhost", "Port": 5001 &#125; ], "UpstreamPathTemplate": "/&#123;url&#125;", "UpstreamHttpMethod": [ "Get", "Post", "Put", "Delete", "Patch" ], "AuthenticationOptions": &#123; // 添加IdentityServer4 "AuthenticationProviderKey": "ocelotKey", "AllowedScopes": [] &#125;, "ServiceName": "order", // 使用consul的时候配置，consul的服务名称 "LoadBalancerOptions": &#123; // 使用consul的时候配置 "Type": "LeastConnection" // 使用consul的时候配置，RoundRobin（轮询方式）和LeastConnection（最小连接） &#125;, // 使用consul的时候配置 "UseServiceDiscovery": true // 使用consul的时候配置，是否启用服务发现 &#125;, &#123; "DownstreamPathTemplate": "/&#123;url&#125;", "DownstreamScheme": "http", "DownstreamHostAndPorts": [ &#123; "Host": "localhost", "Port": 5002 &#125; ], "UpstreamPathTemplate": "/api/&#123;url&#125;", "UpstreamHttpMethod": [ "Get", "Post", "Put", "Delete", "Patch" ] &#125; ], "GlobalConfiguration": &#123; "BaseUrl": "http://localhost:5000", "ServiceDiscoveryProvider": &#123; //使用consul的时候配置，配置服务发现 "Host": "localhost", //使用consul的时候配置，主机地址 "Port": 8500, //使用consul的时候配置，端口 "Type": "Consul", //使用consul的时候配置 "PollingInterval": 100 //使用consul的时候配置，轮询的间隔时间，以毫秒为单位。 &#125;&#125; 修改StartUp 123456789101112131415161718192021222324252627282930313233services.AddAuthentication(IdentityServerAuthenticationDefaults.AuthenticationScheme).AddIdentityServerAuthentication("ocelotKey", options =&gt; &#123; options.Authority = "http://dev.oauth.fanyouvip.com"; options.RequireHttpsMetadata = false; options.ApiName = "apigetway"; options.SupportedTokens = SupportedTokens.Both; options.ApiSecret = "secret";&#125;);services.AddOcelot(new ConfigurationBuilder().AddJsonFile("ocelot.json").Build()).AddConsul();app.UseAuthentication().UseOcelot().Wait();#### 服务注册``` json//注册地址，[PUT] http://localhost:8500/v1/agent/service/register // Body &#123; "ID": "order001", "Name": "order", "Tags": [ "order", "v1" ], "Address": "localhost", "Port": 5001, "EnableTagOverride": false, "Check": &#123; "DeregisterCriticalServiceAfter": "12h", "HTTP": "http://localhost:5001/health", "Interval": "1s" &#125;&#125; Source CodeOcelot DocConsul Doc 服务注册应用程序设计什么是分布式事务随着微服务架构的普及，一个大型业务系统往往由若干个子系统构成，这些子系统又拥有各自独立的数据库。往往一个业务流程需要由多个子系统共同完成，而且这些操作可能需要在一个事务中完成。在微服务系统中，这些业务场景是普遍存在的。此时，我们就需要在数据库之上通过某种手段，实现支持跨数据库的事务支持，这也就是大家常说的“分布式事务”。 CAP理论 CAP理论说的是：在一个分布式系统中，最多只能满足C、A、P中的两个需求。 CAP的含义： C：Consistency 一致性 同一数据的多个副本是否实时相同。 A：Availability 可用性 可用性：一定时间内 &amp; 系统返回一个明确的结果 则称为该系统可用。 P: Partition tolerance 分区容错性 将同一服务分布在多个系统中，从而保证某一个系统宕机，仍然有其他系统提供相同的服务。 对于一个业务系统来说，可用性和分区容错性是必须要满足的两个条件，并且这两者是相辅相成的。业务系统之所以使用分布式系统，主要原因有两个： 提升整体性能 当业务量猛增，单个服务器已经无法满足我们的业务需求的时候，就需要使用分布式系统，使用多个节点提供相同的功能，从而整体上提升系统的性能，这就是使用分布式系统的第一个原因。 实现分区容错性 单一节点 或 多个节点处于相同的网络环境下，那么会存在一定的风险，万一该机房断电、该地区发生自然灾害，那么业务系统就全面瘫痪了。为了防止这一问题，采用分布式系统，将多个子系统分布在不同的地域、不同的机房中，从而保证系统高可用性。 BASE理论CAP理论告诉我们一个悲惨但不得不接受的事实——我们只能在C、A、P中选择两个条件。而对于业务系统而言，我们往往选择牺牲一致性来换取系统的可用性和分区容错性。不过这里要指出的是，所谓的“牺牲一致性”并不是完全放弃数据一致性，而是牺牲强一致性换取弱一致性。 BA：Basic Available 基本可;整个系统在某些不可抗力的情况下，仍然能够保证“可用性”，即一定时间内仍然能够返回一个明确的结果。 S：Soft State：柔性状态 同一数据的不同副本的状态，可以不需要实时一致。 E：Eventual Consisstency：最终一致性 同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。 基于可靠消息服务的分布式事务Dotnetcore.CAP 是一个基于 .NET Standard 的 C# 库，它是一种处理分布式事务的解决方案，同样具有 EventBus 的功能，它具有轻量级、易使用、高性能等特点。 CAP架构图 DotNetCore.CAP Source CodeCAP Demo Source Code 任务调度中心Hangfire 新建项目，添加一下包 123Hangfire.HttpJobHangfire.MySqlStorageHangfire.Dashboard.BasicAuthorization 修改Startup.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// ConfigureServicesservices.AddHangfire(ConfigurationHangfire);// Configure// 中文面板System.Threading.Thread.CurrentThread.CurrentUICulture = new System.Globalization.CultureInfo("zh-app.UseHangfireServer(new BackgroundJobServerOptions()&#123; // queue name参数只能由小写字母、数字、下划线和破折号（自1.7.6起）字符组成。 Queues = Configuration["queue"].Split(new char[','], StringSplitOptions.RemoveEmptyEntries)//只读面板，只能读取不能操作app.UseHangfireDashboard("/read", readOpti// 管理员面板app.UseHangfireDashboard("/jobs", adminOptions);//Hangfire配置 https://github.com/yuzd/Hangfire.HttpJob/wikiprivate DashboardOptions adminOptions = new DashboardOptions()&#123; DisplayStorageConnectionString = false, IsReadOnlyFunc = context =&gt; false, IgnoreAntiforgeryToken = true, Authorization = new[] &#123; new BasicAuthAuthorizationFilter(new BasicAuthAuthorizationFilterOptions() &#123; RequireSsl=false, SslRedirect=false, LoginCaseSensitive=true, Users=new []&#123; new BasicAuthAuthorizationUser &#123; Login="admin", PasswordClear="123" &#125;, new BasicAuthAuthorizationUser &#123; Login="fanyou", PasswordClear="123" &#125; &#125; &#125;)&#125;&#125;;private DashboardOptions readOptions = new DashboardOptions()&#123; IgnoreAntiforgeryToken = true, DisplayStorageConnectionString = false, IsReadOnlyFunc = context =&gt; true&#125;;private void ConfigurationHangfire(IGlobalConfiguration globalConfiguration)&#123; globalConfiguration.UseStorage( new MySqlStorage(Configuration["jobdb"], new MySqlStorageOptions() &#123; QueuePollInterval = TimeSpan.FromSeconds(15), JobExpirationCheckInterval = TimeSpan.FromHours(1), CountersAggregateInterval = TimeSpan.FromMinutes(5), PrepareSchemaIfNecessary = true, DashboardJobListLimit = 50000, TransactionTimeout = TimeSpan.FromMinutes(2), TablesPrefix = "Fairhr_" &#125;)) .UseConsole() .UseHangfireHttpJob(new HangfireHttpJobOptions() &#123; DashboardName = "泛亚统一任务调度平台", DashboardTitle = "调度平台", DashboardFooter = string.Empty, MailOption = new MailOption() &#123; Server = "smtp.qq.com", Port = 465, UseSsl = true, User = "510423039@qq.com", Password = "vkskogjacsqabjgd" &#125; &#125;)&#125; 在任务调度平台添加周期性任务 在任务调度平台添加延迟任务 通过接口注册定时任务和延迟任务123456789101112131415161718192021222324//Install-Package Hangfire.HttpJob.Client// 定时任务var result = HangfireJobClient.AddRecurringJob("调度平台Server地址", new RecurringJob()&#123; JobName = "测试5点40执行", Method = "Post", Data = new &#123;name = "aaa",age = 10&#125;, Url = "http://localhost:5000/api/vaules", Mail = new List&lt;string&gt; &#123; "510423039@qq.com" &#125;, SendSucMail = true, Cron = "40 17 * * *"&#125;//延迟任务var result = HangfireJobClient.AddBackgroundJob("调度平台Server地址", new BackgroundJob&#123; JobName = "测试api", Method = "Get", Url = "http://localhost:5000/api/values/11", Mail = new List&lt;string&gt; &#123;"510423039@qq.com"&#125;, SendSucMail = true, DelayFromMinutes = 1&#125; 日志中心Exceptionless Exceptionless 是一个开源的实时的日志收集框架，它可以应用在基于 ASP.NET，ASP.NET Core，Web Api，Web Forms，WPF，Console，MVC 等技术栈的应用程序中，并且提供了Rest接口可以应用在 Javascript，Node.js 中。 首先，需要去官网注册一个帐号，注册完成之后登录系统。 Install-Package Exceptionless.AspNetCore app.UseExceptionless(“key”); 容器服务部署]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes]]></title>
    <url>%2F2019%2F09%2F02%2FCICD%2FKubernetes%2F</url>
    <content type="text"><![CDATA[使用阿里云镜像安装Kubernetes 前期准备 安装Docker;修改docker镜像源12345678910cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgexclude=kube*EOF 1234567891011121314151617181920212223242526# 禁用主机SELinux，让容器可以读取主机文件系统setenforce 0# 关闭防火墙systemctl disable firewalldsystemctl stop firewalld# 安装kubeadm和相关工具yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes# 设置开机启动 systemctl enable kubelet systemctl start bubelet# 执行kubeadm config print init-defaults，可以获取默认的初始化配置kubeadm config print init-defaults &gt; init.default.yaml# 对生成的文件进行编辑，可以按需生成合适的配置。# 例如，如需要定制镜像仓库的地址，以及pod的地址网络范围，可以使用如下配置，保存为init-config.yamlapiVersion: kubernetes,k8s.io/v1beta1kind: ClusterConfigurationimageRepository: docker.io/dustisekubernetesVersion: v1.14.0networking: podSubnet: "192.168.0.0/16"# 禁用 swap (启用命令：swapon -a)swapoff -a#下载kubernetes所需要的相关镜像kubeadm config images pull --config=init-config.yaml]]></content>
  </entry>
  <entry>
    <title><![CDATA[Restful-Web-API]]></title>
    <url>%2F2019%2F08%2F31%2FCICD%2FRestful-Web-API%2F</url>
    <content type="text"><![CDATA[Rest不是一个协议，也不是一种文件格式，更不是一种开发框架。它是一系列的涉及约束的集合：无状态性，讲超媒体作为应用状态的引擎等。 服务器发送的表述用于描述资源当前的状态，客户端发送的表述用于描述客户端希望资源拥有的状态，这就是表述性状态转移。 GET 获取资源的某个表述，请求成功返回200 POST 基于给定的表述信息，在当前资源的下一级创建新的资源，（201，创建成功，202表示服务器按照提供的表述信息来创建一个资源，但是现在还没有真正的创建完成），不安全也不幂等。 DELETE 销毁一个资源，（如果一个delete请求成功，服务器可能返回204表示已经删除成功了，或者是200，也有可能是202意识是讲在稍后删除这个资源），如果试图通过get访问一个被删除的资源，应该是404或者410. PUT 用给定的表述信息替换资源的当前状态，（返回200或者204）用于修改资源状态的请求，发送10次put请求和1次结果都是一样的，所以是幂等的。 幂等性：发送多次请求对资源的状态的影响和发送一次的请求的影响是一样的。（get和delete和put是幂等性安全的方法），幂等的概念来源于数学，零乘运算就是幂等运算，讲一个值乘以0等到的都是同样的结果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Https]]></title>
    <url>%2F2019%2F08%2F27%2FCICD%2FHttps%2F</url>
    <content type="text"><![CDATA[Http的定义 http提供了一组规则和标准，从而让信息能够在互联网上进行传播。 http 超文本传输协议；tcp 传输控制协议 ；ip 网间协议； 通过ip地址+协议+端口标识网络中的一个进程，标识唯一一个进程之后，就可以进行socket通信了，socket是应用层和传输层之间的一个抽象层，它把tcp/ip层复杂的操作抽象为几个简单的接口提供给应用层调用，实现网络中的通信。 socket是对tcp/ip的封装，socket本事并不是协议，而是一个调用接口，通过socket，我们才能使用tcp/ip协议。 TCP/IP 五层模型 应用层：负责应用程序之间的沟通。网络编程主要针对的就是应用层,（http,ftp,邮件协议[SMTP、POP3、IMAP4]） 传输层：负责两台主机之间的数据传输,(tcp) 网络层：负责地址管理和路由选择。路由器工作在网络层,(ip) 数据链路层：负责设备之间的数据帧的传输和识别。交换机工作在数据链路层。例如网卡设备的驱动，帧同步，冲突检测，数据差错校验等工作,(以太网协议) 物理层：负责光电信号传递方式。集线器工作在物理层。以太网协议 http是无状态 http是基于tcp/ip协议，当一个tcp连接关闭之后，所有的http请求和响应信息全部消失，在http中，客户端通过socket技术创建一个tcp/ip连接，并且连接到服务器，完成信息交换后，就会关闭tcp连接。所谓的无状态就是每次完成请求后,不会在客户端和服务端保存任何信息，对于客户端和服务端来说，根本不知道上次的请求信息是什么，它的生命周期随着tcp/ip的关闭结束了。 http本事是不能传输的，需要通过网络层中的其他协议进行通信，一般构建在tcp之上，tcp提供一个可靠的，面向连接的传输服务。 协议不安全的原因 数据没有加密 无法验证身份 数据容易篡改 对称加密算法 块密码算法 - 每次对固定长度的数据库进行加密，可能要经过一次或者多次运算，最终得到密文。 流密码算法 - 明文和同样长度的序列进行XOR运算得到密文。密文与加密使用的序列再进行XOR运算得到明文。 非对称加密算法(公开密钥算法) 和对称加密算法功能不一样，用来加密和解密，密钥协商，数字签名。 密钥是一对（公钥和私钥） 运行速度很慢，公开加密算法尤其是RSA算法运行非常缓慢，一般情况下，需要加密得明文数据很大，如果用非对称加密算法，运行性能会惨不忍睹。 消息验证码 MAC(message authentication code) hash算法能够实现完整性校验，但是不能避免消息被篡改，为避免消息被篡改，需要用到消息验证码。 发送方和接收方维护一个密钥，然后生成验证消息码，可以和原始消息一起传递，原始消息也可以加密，接收方比较mac值。 HTTP+LTS/SSL协议组合在一起就是https，就是说https拥有http得所有特征，并且http消息由TLS/SSL协议进行安全保护。 客户端发送https请求就是连接服务器443端口，讲所有得http数据传递给TLS/SSL协议，最终由TLS/SSL协议传递给TCP传输层。 TLS/SSL协议三大核心步骤：认证，密钥协商，数据加密。 在HTTPS协议中，客户端和服务端双方是互相不认识得，客户端可以是世界上任何一台机器得浏览器，必须采用动态密钥分配方式，这个时候密钥协商算法就出场了。 在公开密钥算法中，所有的网络通信都会存在中间人攻击，在https中必须引入PKI技术解决身份验证的问题，PKI的核心技术就是证书。PKI技术能够确保客户端接收到的服务器公钥确实是期待服务端的公钥。]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件流]]></title>
    <url>%2F2019%2F08%2F06%2Fcsharp%2F%E6%96%87%E4%BB%B6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[文件 文件是存储在具有特定名称和目录路径的磁盘中的数据的集合。当文件打开以进行读取或写入时，它将成为流。 流基本上是通过通信路径的字节序列。有两个主要流：输入流和输出流。输入流用于从文件读取数据(读取操作)，输出流用于写入文件(写入操作)。 FileStream12345678910111213// 写入FileStream f = new FileStream("e:\\filestream-demo.txt", FileMode.OpenOrCreate);//creating file stream f.WriteByte(65);//writing byte into stream f.Close();//closing stream// 读取FileStream f = new FileStream("e:\\filestream-demo.txt", FileMode.OpenOrCreate);int i = 0; while ((i = f.ReadByte()) != -1) &#123; Console.Write((char)i); &#125; f.Close(); StreamReader1234567891011121314151617181920// 一行一行读取FileStream f = new FileStream("e:\\myoutput.txt", FileMode.OpenOrCreate);StreamReader s = new StreamReader(f);string line = s.ReadLine();Console.WriteLine(line);string line2 = s.ReadLine();Console.WriteLine(line2);s.Close();f.Close();// 读取所有FileStream f = new FileStream("e:\\myoutput.txt", FileMode.OpenOrCreate);StreamReader s = new StreamReader(f);string line = "";while ((line = s.ReadLine()) != null)&#123; Console.WriteLine(line);&#125;s.Close();f.Close(); 大文本拷贝123456789101112131415161718192021222324252627282930313233private static void CopyFile(string source, string target) &#123; //创建一个读文件的流 using (FileStream fsread = new FileStream(source, FileMode.Open)) &#123; //创建一个写文件流 using (FileStream fswrite = new FileStream(target, FileMode.Create)) &#123; //创建一个读取文件、写入文件的一个缓冲区 //设置缓冲区大小，每次读取内容放到缓冲区中 byte[] buffer = new byte[1024 * 1024 * 10];//10MB long len = fsread.Length; //开始读取 while (true) &#123; //r 表示本次读到的字节数 int r = fsread.Read(buffer, 0, buffer.Length); if (r &lt;= 0) //已经到了文件末尾 &#123; break; &#125; else //读到了内容 &#123; fswrite.Write(buffer, 0, r); long allong = fswrite.Length; //已经拷贝的长度 double proc = (double)allong / len; Console.WriteLine("复制进度：" + proc + "%"); &#125; &#125; &#125; &#125; &#125; https://www.yiibai.com/csharp/c-sharp-stringreader.html]]></content>
      <categories>
        <category>DotNet</category>
      </categories>
      <tags>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css属性]]></title>
    <url>%2F2019%2F08%2F06%2F%E5%89%8D%E7%AB%AF%2FCss%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[行内元素和块级元素 行内元素会在一条直线上排列（默认宽度只与内容有关），都是同一行的，水平方向排列。 块级元素各占据一行（默认宽度是它本身父容器的100%（和父元素的宽度一致），与内容无关），垂直方向排列。块级元素从新行开始，结束接着一个断行。 块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素，只能包含文本或者其它行内元素。 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效 行内元素和块级元素转换 display:block; (字面意思表现形式设为块级元素) display:inline; (字面意思表现形式设为行内元素) inline-block 的元素（如input、img)既具有 block 元素可以设置宽高的特性，同时又具有 inline 元素默认不换行的特性。当然不仅仅是这些特性，比如 inline-block 元素也可以设置 vertical-align（因为这个垂直对齐属性只对设置了inline-block的元素有效） 属性。HTML 中的换行符、空格符、制表符等合并为空白符，字体大小不为 0 的情况下，空白符自然占据一定的宽度，使用inline-block 会产生元素间的空隙。 行内元素和块级元素区别]]></content>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Consul]]></title>
    <url>%2F2019%2F07%2F21%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%2FConsul%2F</url>
    <content type="text"><![CDATA[Consul Consul包含多个组件,但是作为一个整体,为你的基础设施提供服务发现和服务配置的工具。 服务发现：Consul的客户端可提供一个服务，比如api或者mysql，另外一些客户端可使用Consul去发现一个指定的服务提供者，通过DNS或者Http应用程序很容易找到他依赖的服务。 健康检查：Consul客户端可提供任意数量的健康检查，指定一个服务（比如一个api是否返回了200）或者使用本地节点（比如内存是否大于90%），这个信息可由opreator用来监视集群的健康，被服务发现组件用来避免将流量发送到不健康的主机。 Key/Value存储：应用程序可根据自己需要使用的Consul的层级的Key/Value存储，比如动态配置，功能标记，协调，领袖选举等。 多数据中心：Consul支持开箱即用的多数据中心，这意味着用户不需要担心建立额外的抽象层让业务扩展到多个区域，Consul面对DevOps和应用开发者友好，是他适合现代弹性的基础设置。 Consul使用场景 Docker 实例的注册与配置共享。 Coreos 实例的注册与配置共享。 SaaS 应用的配置共享、服务发现和健康检查。 vitess 集群。 与 confd 服务集成，动态生成 nginx 和 haproxy 配置文件。 Consul优势 市面现在有很多类似的软件比如：zookeeper 、Etcd、doozerd、eureka，Consul 相比这些软件有什么优势呢？ 使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言, zookeeper 采用的是 Paxos, 而 etcd 使用的则是 Raft。 支持 多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障，而其部署则需要考虑网络延迟，分片等情况等. zookeeper 和 etcd 均不提供多数据中心功能的支持。 支持 健康检查。 etcd 不提供此功能。 支持 HTTP、DNS 和 GPRS 协议接口。 zookeeper 的集成较为复杂，etcd 只支持 http 协议。 官方提供 WEB管理界面，etcd 无此功能。 Glossary Client：表示 Consul 客户端模式，是 Consul 节点的一种模式，所有注册到 Client 节点的服务会被转发到 Server 。本身无状态不持久化如何数据。Client 通过 HTTP、DNS、GRPC 接口请求转发给局域网内的服务端集群。 Server：表示 Consul 的服务端模式， Server 功能和 Client 都一样，不同的是 Server 持久化数据到本地。在局域网内与本地 Client 通讯，通过广域网与其他数据中心通讯。每个数据中心的 Server 数量推荐为 3 个或是 5 个。 Server-Leader ：表示这个 Server 是它们的老大，它和其它 Server 不一样的一点是，它需要负责同步注册的信息给其它的 Server 节点，同时也要负责各个节点的健康监测。如果 Leader 宕机了，通数据中心的所有 Server 内部会使用 Raft 算法来在其中选取一个 Leader 出来。 Agent ：Agent 是 Consul 的核心进程，Agent 的工作是维护成员关系信息、注册服务、健康检查、响应查询等等。Consul 集群的每一个节点都必须运行 agent 进程。 Consul的工作原理 使用微服务架构。传统的单体架构不够灵活不能很好的适应变化，从而向微服务架构进行转换，而伴随着大量服务的出现，管理运维十分不便，于是开始搞一些自动化的策略，服务发现应运而生。但是引入服务发现就可能引入一些技术栈，增加系统总体的复杂度。 在服务器Server1、Server2、Server3上分别部署了Consul Server，假设他们选举了Server2上的Consul Server节点为Leader. 在服务器Server4和Server5上通过Consul Client分别注册Service A、B、C。服务注册到Consul可以通过HTTP API（8500端口）的方式，也可以通过Consul配置文件的方式。Consul Client可以认为是无状态的，它将注册信息通过RPC转发到Consul Server，服务信息保存在Server的各个节点中，并且通过Raft实现了强一致性。 在服务器Server6中Program D需要访问Service B，这时候Program D首先访问本机Consul Client提供的HTTP API，本机Client会将请求转发到Consul Server，Consul Server查询到Service B当前的信息返回，最终Program D拿到了Service B的所有部署的IP和端口，然后就可以选择Service B的其中一个部署并向其发起请求了。如果服务发现采用的是DNS方式，则Program D中直接使用Service B的服务发现域名，域名解析请求首先到达本机DNS代理，然后转发到本机Consul Client，本机Client会将请求转发到Consul Server，Consul Server查询到Service B当前的信息返回，最终Program D拿到了Service B的某个部署的IP和端口。 http://blog.didispace.com/consul-service-discovery-exp 参数说明 advertise：通知展现地址用来改变我们给集群中的其他节点展现的地址，一般情况下-bind地址就是展现地址。 bootstrap： 用来控制一个server是否在bootstrap模式，在一个datacenter中只能有一个server处于bootstrap模式，当一个server处于bootstrap模式时，可以自己选举为raft leader。 bootstrap-expect：在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap共用。 bind：该地址用来在集群内部的通讯IP地址，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0。 client：consul绑定在哪个client地址上，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1。 config-file：明确的指定要加载哪个配置文件。 config-dir：配置文件目录，里面所有以.json结尾的文件都会被加载。 data-dir：提供一个目录用来存放agent的状态，所有的agent允许都需要该目录，该目录必须是稳定的，系统重启后都继续存在。 dc:该标记控制agent允许的datacenter的名称，默认是dc1。 encrypt： 指定secret key，使consul在通讯时进行加密，key可以通过consul keygen生成，同一个集群中的节点必须使用相同的key。 join：加入一个已经启动的agent的ip地址，可以多次指定多个agent的地址。如果consul不能加入任何指定的地址中，则agent会启动失败，默认agent启动时不会加入任何节点。 retry-interval：两次join之间的时间间隔，默认是30s。 retry-max：尝试重复join的次数，默认是0，也就是无限次尝试。 log-level：consul agent启动后显示的日志信息级别。默认是info，可选：trace、debug、info、warn、err。 node：节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名。 protocol：consul使用的协议版本。 rejoin：使consul忽略先前的离开，在再次启动后仍旧尝试加入集群中。 server：定义agent运行在server模式，每个集群至少有一个server，建议每个集群的server不要超过5个。 syslog：开启系统日志功能，只在linux/osx上生效。 pid-file：提供一个路径来存放pid文件，可以使用该文件进行SIGINT/SIGHUP(关闭/更新)agent。 1234567891011121314151617# 启动Consul和web管理docker run -d -p 8001:8500 --name consulserver-01 consul agent -server -bootstrap -ui -node=Node-01 -client='0.0.0.0' -data-dir ~/consul/data -config-dir ~/consul/configdocker run -d --name consulserver-02 consul agent -server -bootstrap -ui -node=Node-02 -client='0.0.0.0' -data-dir /var/vdb1/wangjun/consul/data -config-dir /var/vdb1/wangjun/consul/config -join='172.17.0.2'docker run -d --name consulserver-03 consul agent -server -bootstrap -ui -node=Node-03 -client='0.0.0.0' -data-dir /var/vdb1/wangjun/consul/data -config-dir /var/vdb1/wangjun/consul/config -join='172.17.0.2'docker run -d --name consulclient-01 consul agent -client -bootstrap -ui -node=Node-client-01 -client='0.0.0.0' -data-dir /var/vdb1/wangjun/consul/data -config-dir /var/vdb1/wangjun/consul/config -join='172.17.0.2'# 查看consul信息docker exec consul_server_1 consul members#Node Address Status Type Build Protocol DC Segment#1 172.17.0.2:8301 alive server 1.5.2 2 dc1 &lt;all&gt;#通过命令获取到引导 Consul 的 Ip 地址 172.17.0.2 #加入到集群， 命名为 -node=2 、-node=3 docker run -d --name=consul_server_2 consul agent -server -bootstrap -ui -node=2 -client='0.0.0.0' -join='172.17.0.2' docker run -d --name=consul_server_3 consul agent -server -bootstrap -ui -node=3 -client='0.0.0.0' -join='172.17.0.2' # 添加Client docker run -d --name=consul_server_4 consul agent -client -node=4 -join='172.17.0.2' -client='0.0.0.0' # Client需要集群继续添加node5，6就好]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Consul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Async-Await]]></title>
    <url>%2F2019%2F07%2F21%2Fcsharp%2FAsync-Await%2F</url>
    <content type="text"><![CDATA[Task对象的前世今生 Task对象是.Net Framework 4.0之后出现的异步编程的一个重要对象。在一定程度上来说，Task对象可以理解Thread对象的一个升级产品。 示例 12345678910111213141516171819class Program&#123; static void Main(string[] args) &#123; Console.WriteLine("执行方法之前的时间：" + DateTime.Now.ToString("yyyy-MM-dd hh:MM:sss")); var result = Task.Run(() =&gt;&#123;return GetResult();&#125;); Console.WriteLine("主线程Id:" + Thread.CurrentThread.ManagedThreadId); Console.WriteLine(result.Result); Console.WriteLine("执行方法之后的时间：" + DateTime.Now.ToString("yyyy-MM-dd hh:MM:sss")); Console.ReadKey(); &#125; public static string GetResult() &#123; Thread.Sleep(2000); Console.WriteLine("GetResult的线程Id:" + Thread.CurrentThread.ManagedThreadId); return "WangJunZzz"; &#125;&#125; 结果 123456789#执行方法之前的时间：2019-07-21 01:07:42#WangJunZzz#执行方法之后的时间：2019-07-21 01:07:44#PS E:\Code\async\async-await&gt; dotnet run#执行方法之前的时间：2019-07-21 01:07:52#主线程Id:1#GetResult的线程Id:3#WangJunZzz#执行方法之后的时间：2019-07-21 01:07:54 从结果分析得知，var result = Task.Run(() =&gt;{return GetResult();});这一句后，主线程并没有阻塞取执行GetResult()方法，而是开启一个线程取执行GetResult()方法。知道执行result.Result这一句的时候才会等待GetResult()方法执行完毕。由此可知，Task.Run(()=&gt;{}).Reslut是阻塞主线程的，主要因为主线程要得到返回值，必须等方法执行完毕。 线程不安全 示例 12345678910111213141516171819class Program&#123; private static bool isDone = false; static void Main(string[] args) &#123; new Thread(Done).Start(); new Thread(Done).Start(); Console.ReadKey(); &#125; static void Done() &#123; if (!isDone) &#123; Console.WriteLine("Done"); isDone = true; &#125; &#125;&#125; 结果 12#Done#Done 第一个线程还没有来得及把isDone设置成true，第二个线程就进来了，而这不是我们想要的结果，在多个线程下，结果不是我们的预期结果，这就是线程不安全。 锁 示例1234567891011121314151617181920212223class Program&#123; private static bool isDone = false; private static object mylock = new object(); static void Main(string[] args) &#123; new Thread(Done).Start(); new Thread(Done).Start(); Console.ReadKey(); &#125; static void Done() &#123; lock(mylock) &#123; if (!isDone) &#123; Console.WriteLine("Done"); isDone = true; &#125; &#125; &#125;&#125; 加上锁之后，被锁住的代码在同一个时间内只允许一个线程访问，其它的线程会被阻塞，只有等到这个锁被释放之后其它的线程才能执行被锁住的代码。 Async,Await 使用它们，方法的返回类型应为Task类型。为了使用await关键字，您必须在方法定义中使用async。如果你在方法定义中放入async，你应该在主体方法的某个地方至少有一处await关键字，如果你缺少他，你通常会收到Visual Studio的一个警告。 await 之后不会开启新的线程(await 从来不会开启新的线程)。 加上await关键字之后，后面的代码会被挂起等待，直到task执行完毕有返回值的时候才会继续向下执行，这一段时间主线程会处于挂起状态。 Task.Run(()=&gt;{}); 将一个任务添加到线程池里，排队执行。 async 标识一个方法为异步方法，可以与主线程并行执行，发挥CPU的多核优势。 await 在调用一个async方法前可以添加这个修饰符，它意思是等待当前异步方法执行完后，再执行下面的代码。 ConfigureAwait(true)，代码由同步执行进入异步执行时，当前线程上下文信息就会被捕获并保存至 SynchronizationContext中，供异步执行中使用，并且供异步执行完成之后的同步执行中使用。 Configurewait(flase)，不进行线程上下文信息的捕获，async方法中与await之后的代码执行时就无法获取await之前的线程的上下文信息，在ASP.NET中最直接的影响就是HttpConext.Current的值为null，但不会出现非空引用的错误。 async配合Task是为了简化异步调用，异步调用的目的恰恰就是为了释放线程资源。 在await的时候，线程就被释放了，等到异步操作完成才会回头来继续执行后面的代码。async的用途恰恰就在于避免阻塞，写的代码看起来像是同步的阻塞代码，但编译后不是，这才是async的精髓。(https://www.cnblogs.com/jesse2013/p/async-and-await.html 评论)。 在.NetCore中我们不用继续关心异步同步混用情况下，是否哪里没有设置ConfigureAwait(false) 会导致的死锁问题，因为在.netcore中的async/await 可能在任何线程上执行，并且可能并行运行！。]]></content>
      <categories>
        <category>DotNet</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus]]></title>
    <url>%2F2019%2F07%2F09%2Fcsharp%2FEventBus%2F</url>
    <content type="text"><![CDATA[引言 事件总线这个概念对你来说可能很陌生，但提到观察者（发布-订阅）模式，你也许就很熟悉。事件总线是对发布-订阅模式的一种实现。它是一种集中式事件处理机制，允许不同的组件之间进行彼此通信而又不需要相互依赖，达到一种解耦的目的。 本质：事件是由事件源和事件处理组成。 发布订阅模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 ——发布订阅模式。 基本思路 在事件总线内部维护着一个事件与事件处理程序相映射的字典。 利用反射，事件总线会将实现了IEventHandler的处理程序与相应事件关联到一起，相当于实现了事件处理程序对事件的订阅。 当发布事件时，事件总线会从字典中找出相应的事件处理程序，然后利用反射去调用事件处理程序中的方法。 基于内存事件总线实现 定义一个事件接口 123public interface IEvent&#123;&#125; 定义一个事件处理接口 1234public interface IEventHandler : IEvent&#123; Task Handle(IEvent e);&#125; 定义一个发布接口 1234public interface IEventPublisher&#123; Task Publish&lt;TEvent&gt;(TEvent e) where TEvent : IEvent;&#125; 定义一个发布接口 1234public interface IEventSubscriber &#123; Task Subscribe&lt;TEvent, EH&gt;() where TEvent : IEvent where EH : class, IEventHandler, new();&#125; 创建一个类用来存事件 1234public static class MemoryMq&#123; public static ConcurrentDictionary&lt;string, IEvent&gt; eventQueueDict &#123; get; set; &#125;&#125; 实现发布类 12345678910111213public class InMemoryEventPublisher : IEventPublisher&#123; public Task Publish&lt;TEvent&gt;(TEvent e) where TEvent : IEvent &#123; if (e == null) return Task.CompletedTask; if (MemoryMq.eventQueueDict == null) &#123; MemoryMq.eventQueueDict = new ConcurrentDictionary&lt;string, IEvent&gt;(); &#125; MemoryMq.eventQueueDict.GetOrAdd(Guid.NewGuid().ToString(), e); return Task.CompletedTask; &#125;&#125; 实现订阅类 1234567891011121314151617181920212223public class InMemoryEventSubscriber : IEventSubscriber&#123; public Task Subscribe&lt;TEvent, EH&gt;() where TEvent : IEvent where EH : class, IEventHandler, new() &#123; EH state = new EH(); Task.Run(() =&gt; &#123; while (true) &#123; if (MemoryMq.eventQueueDict != null) &#123; foreach (var item in MemoryMq.eventQueueDict) &#123; state.Handle(item.Value as IEvent); IEvent o; MemoryMq.eventQueueDict.TryRemove(item.Key, out o); &#125; &#125; &#125; &#125;); return Task.CompletedTask; &#125; 实现逻辑处理 123456789101112131415161718public class EventHandler : IEventHandler&#123; public Task Handle(IEvent e) &#123; switch (e) &#123; case Order value: Console.WriteLine(value.Name); break; &#125; return Task.CompletedTask; &#125;&#125; public class Order : IEvent &#123; public string name &#123; get; set; &#125; &#125; 测试 1234567891011121314class Program&#123; static void Main(string[] args) &#123; var pub = new InMemoryEventPublisher(); var sub = new InMemoryEventSubscriber(); sub.Subscribe&lt;Order, EventHandler&gt;(); var order = new Order(); order.Name = "wangjunzzz"; pub.Publish(order); Console.WriteLine("Hello World!"); Console.ReadKey(); &#125;&#125; Code Source]]></content>
      <categories>
        <category>DotNet</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMq]]></title>
    <url>%2F2019%2F06%2F27%2Fcsharp%2FRabbitMq%2F</url>
    <content type="text"><![CDATA[消息中间件 消息中间件是指利用高效可靠得消息传递机制进行与平台数据无关的数据交流，并基于数据通信来进行分布式系统集成。 RabbitMq整体上是一个生产者和消费者模型，主要负责接收，存储和转发消息。 RabbitMq就是AMQP(应用层高级消息队列协议)协议的Erlang的实现。 作用 解耦：独立修改或者扩展两边的处理过程，只要确保遵循相同的接口约束即可。 削峰：使用中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩溃。 异步通信：很多时候不想立即处理消息，中间件允许把消息放到中间件中，但是不立即处理它，之后需要的时候在慢慢处理。 名词解释 生产者：投递消息的一方. 消费者: 接收消息的一方. Broker：消息中间件的服务节点. Queue: 队列，RabbitMq的内部对象. 交换器：生产者把消息发送到Exchange（交换器）,由交换器把消息路由到一个或者多个队列中,如果路由不到,或许会返回给生产者,或许会直接丢弃.RabbitMq有四种交换机类型:交换机类型 五种模式 简单模式：一个生产者，一个消费者. 简单模式特点，其实就是是生成者直接将消息发送给队列，消费者直接从队列取消息，中间没有其他的东西，并且1对1的。 生产者 123456789101112131415161718192021222324252627282930//创建mq的连接工厂var factory = new ConnectionFactory();factory.HostName = "119.29.225.20";factory.UserName = "userId";factory.Password = "pwd";//创建一个连接var connection = factory.CreateConnection();//创建一个频道var channel = connection.CreateModel();//创建一个队列// durable:持久化可以把交换器存盘，在服务器重启的时候不会丢失相关信息.// exclusive:如果申明为排它队列,该队列仅对首次申明它的连接可见,并且在连接断开的时候自动删除,// autoDelete:是否自动删除,自动删除的前提是：至少又一个消费者连接到这个队列,// 之后所有与这个队列连接的消费者都断开时,才会自动删除.channel.QueueDeclare(queue: "hello", durable: false, exclusive: false, autoDelete: false, arguments: null);for (int i = 0; i &lt; 50; i++)&#123; string message = "Hello World!"+i; var body = Encoding.UTF8.GetBytes(message) // 发送消息 channel.BasicPublish(exchange: "", routingKey: "hello", basicProperties: null, body: body); Console.WriteLine(" [x] Sent &#123;0&#125;", message);&#125; 消费者 1234567891011121314151617181920212223242526var factory = new ConnectionFactory();factory.HostName = "119.29.225.20";factory.UserName = "userId";factory.Password = "pwd";using (var connection = factory.CreateConnection())&#123; using (var channel = connection.CreateModel()) &#123; channel.QueueDeclare(queue: "hello", durable: false, exclusive: false, autoDelete: false, arguments: null); var consumer = new EventingBasicConsumer(channel); consumer.Received += (model, ea) =&gt; &#123; var body = ea.Body; var message = Encoding.UTF8.GetString(body); Console.WriteLine(" [x] Received &#123;0&#125;", message); &#125;; channel.BasicConsume(queue: "hello", autoAck: true, consumer: consumer); Console.ReadKey(); &#125;&#125; 工作模式：一个生产者,多个消费者. 消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2,同时监听同一个队列,消息被消费?C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患,高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize,与同步锁的性能不一样) 保证一条消息只能被一个消费者使用).一条消息只会被一个消费者接收；rabbit采用轮询的方式将消息是平均发送给消费者的；消费者在处理完某条消息后，才会收到下一条消息. 12]]></content>
      <categories>
        <category>Plugs/RabbitMq</category>
      </categories>
      <tags>
        <tag>RabbitMq</tag>
      </tags>
  </entry>
</search>
