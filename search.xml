<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[{ “service”: { “id”: “oauth”, “name”: “dev-oauth”, “tags”: [“fanyou”], “address”: “http://dev.oauth.fanyouvip.com&quot;, “port”: 80, &quot;checks&quot;: [ { &quot;HTTP&quot;:&quot;http://dev.oauth.fanyouvip.com&quot;, &quot;interval&quot;: &quot;10s&quot; } ] }}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Apollo]]></title>
    <url>%2F2019%2F09%2F16%2FApollo%2F</url>
    <content type="text"><![CDATA[携程Apollo再.Net FrameWork上的使用 新建一个.Net Framework4.7.2的项目 添加Com.Ctrip.Framework.Apollo.ConfigurationManager包引用 再Web.config的appSettings目录下添加 12&lt;add key="Apollo.AppId" value="framework.web" /&gt;&lt;add key="Apollo.MetaServer" value="http://192.168.19.48:8080/" /&gt; 获取配置文件 1234// ApolloConfigurationManager 不过这个是过时的IConfig config = await ApolloConfigurationManager.GetAppConfig();// 获取apollo配置好的连接字符串return config.GetProperty("ConnectionStrings", string.Empty); 携程Apollo再.NetCore2.2上的使用 新建一个.NetCore2.2项目 添加Com.Ctrip.Framework.Apollo.Configuration包引用 配置appsettings.json 123456789101112&#123; "apollo": &#123; "AppId": "qa.fanyou.001", //"MetaServer": "http://192.168.19.48:8081", //"Env": "FAT", "Meta": &#123; "DEV": "http://192.168.19.48:8080", "FAT": "http://192.168.19.48:8081", "UAT": "http://192.168.19.48:8082" &#125; &#125;&#125; 在Program-&gt;Main函数中添加 123456789public static IWebHostBuilder CreateWebHostBuilder(string[] args)&#123; return WebHost.CreateDefaultBuilder(args) .ConfigureAppConfiguration(builder =&gt; builder .AddApollo(builder.Build().GetSection("apollo")) //.AddNamespace("fanyou") // 命名空间 .AddDefault()) .UseStartup&lt;Startup&gt;();&#125; 使用方式一(注入IConfiguration)： 12345678910111213141516[Route("api/[controller]")][ApiController]public class ValuesController : ControllerBase&#123; private readonly IConfiguration configuration; public ValuesController(IConfiguration config) &#123; configuration = config; &#125; // GET api/values [HttpGet] public string Get() &#123; return configuration["Test"].ToString(); &#125;&#125; 使用方式二(POCO): 添加Tuhu.Extensions.Configuration.ValueBinder.Json包引用1234567891011121314151617181920// 在apollo中配置文件是Json格式。项目中建立对于的实体services.ConfigureJsonValue&lt;ConfigMsg&gt;(Configuration.GetSection("Test"));// 获取配置文件信息[Route("api/[controller]")][ApiController]public class ValuesController : ControllerBase&#123; private IOptions&lt;ConfigMsg&gt; config; public ValuesController(IOptions&lt;ConfigMsg&gt; configMsg)2 &#123; config = configMsg; &#125; [HttpGet] public int Get() &#123; return config.Value.request_timeout; &#125;&#125; Github源码地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[.NET Core 生成Nuget包]]></title>
    <url>%2F2019%2F09%2F04%2FNET-Core-%E7%94%9F%E6%88%90Nuget%E5%8C%85%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes]]></title>
    <url>%2F2019%2F09%2F02%2FKubernetes%2F</url>
    <content type="text"><![CDATA[使用阿里云镜像安装Kubernetes 前期准备 安装Docker;修改docker镜像源12345678910cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgexclude=kube*EOF 1234567891011121314151617181920212223242526# 禁用主机SELinux，让容器可以读取主机文件系统setenforce 0# 关闭防火墙systemctl disable firewalldsystemctl stop firewalld# 安装kubeadm和相关工具yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes# 设置开机启动 systemctl enable kubelet systemctl start bubelet# 执行kubeadm config print init-defaults，可以获取默认的初始化配置kubeadm config print init-defaults &gt; init.default.yaml# 对生成的文件进行编辑，可以按需生成合适的配置。# 例如，如需要定制镜像仓库的地址，以及pod的地址网络范围，可以使用如下配置，保存为init-config.yamlapiVersion: kubernetes,k8s.io/v1beta1kind: ClusterConfigurationimageRepository: docker.io/dustisekubernetesVersion: v1.14.0networking: podSubnet: "192.168.0.0/16"# 禁用 swap (启用命令：swapon -a)swapoff -a#下载kubernetes所需要的相关镜像kubeadm config images pull --config=init-config.yaml]]></content>
  </entry>
  <entry>
    <title><![CDATA[Restful-Web-API]]></title>
    <url>%2F2019%2F08%2F31%2FRestful-Web-API%2F</url>
    <content type="text"><![CDATA[Rest不是一个协议，也不是一种文件格式，更不是一种开发框架。它是一系列的涉及约束的集合：无状态性，讲超媒体作为应用状态的引擎等。 服务器发送的表述用于描述资源当前的状态，客户端发送的表述用于描述客户端希望资源拥有的状态，这就是表述性状态转移。 GET 获取资源的某个表述，请求成功返回200 POST 基于给定的表述信息，在当前资源的下一级创建新的资源，（201，创建成功，202表示服务器按照提供的表述信息来创建一个资源，但是现在还没有真正的创建完成），不安全也不幂等。 DELETE 销毁一个资源，（如果一个delete请求成功，服务器可能返回204表示已经删除成功了，或者是200，也有可能是202意识是讲在稍后删除这个资源），如果试图通过get访问一个被删除的资源，应该是404或者410. PUT 用给定的表述信息替换资源的当前状态，（返回200或者204）用于修改资源状态的请求，发送10次put请求和1次结果都是一样的，所以是幂等的。 幂等性：发送多次请求对资源的状态的影响和发送一次的请求的影响是一样的。（get和delete和put是幂等性安全的方法），幂等的概念来源于数学，零乘运算就是幂等运算，讲一个值乘以0等到的都是同样的结果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Https]]></title>
    <url>%2F2019%2F08%2F27%2FHttps%2F</url>
    <content type="text"><![CDATA[Http的定义 http提供了一组规则和标准，从而让信息能够在互联网上进行传播。 http 超文本传输协议；tcp 传输控制协议 ；ip 网间协议； 通过ip地址+协议+端口标识网络中的一个进程，标识唯一一个进程之后，就可以进行socket通信了，socket是应用层和传输层之间的一个抽象层，它把tcp/ip层复杂的操作抽象为几个简单的接口提供给应用层调用，实现网络中的通信。 socket是对tcp/ip的封装，socket本事并不是协议，而是一个调用接口，通过socket，我们才能使用tcp/ip协议。 TCP/IP 五层模型 应用层：负责应用程序之间的沟通。网络编程主要针对的就是应用层,（http,ftp,邮件协议[SMTP、POP3、IMAP4]） 传输层：负责两台主机之间的数据传输,(tcp) 网络层：负责地址管理和路由选择。路由器工作在网络层,(ip) 数据链路层：负责设备之间的数据帧的传输和识别。交换机工作在数据链路层。例如网卡设备的驱动，帧同步，冲突检测，数据差错校验等工作,(以太网协议) 物理层：负责光电信号传递方式。集线器工作在物理层。以太网协议 http是无状态 http是基于tcp/ip协议，当一个tcp连接关闭之后，所有的http请求和响应信息全部消失，在http中，客户端通过socket技术创建一个tcp/ip连接，并且连接到服务器，完成信息交换后，就会关闭tcp连接。所谓的无状态就是每次完成请求后,不会在客户端和服务端保存任何信息，对于客户端和服务端来说，根本不知道上次的请求信息是什么，它的生命周期随着tcp/ip的关闭结束了。 http本事是不能传输的，需要通过网络层中的其他协议进行通信，一般构建在tcp之上，tcp提供一个可靠的，面向连接的传输服务。 协议不安全的原因 数据没有加密 无法验证身份 数据容易篡改 对称加密算法 块密码算法 - 每次对固定长度的数据库进行加密，可能要经过一次或者多次运算，最终得到密文。 流密码算法 - 明文和同样长度的序列进行XOR运算得到密文。密文与加密使用的序列再进行XOR运算得到明文。 非对称加密算法(公开密钥算法) 和对称加密算法功能不一样，用来加密和解密，密钥协商，数字签名。 密钥是一对（公钥和私钥） 运行速度很慢，公开加密算法尤其是RSA算法运行非常缓慢，一般情况下，需要加密得明文数据很大，如果用非对称加密算法，运行性能会惨不忍睹。 消息验证码 MAC(message authentication code) hash算法能够实现完整性校验，但是不能避免消息被篡改，为避免消息被篡改，需要用到消息验证码。 发送方和接收方维护一个密钥，然后生成验证消息码，可以和原始消息一起传递，原始消息也可以加密，接收方比较mac值。 HTTP+LTS/SSL协议组合在一起就是https，就是说https拥有http得所有特征，并且http消息由TLS/SSL协议进行安全保护。 客户端发送https请求就是连接服务器443端口，讲所有得http数据传递给TLS/SSL协议，最终由TLS/SSL协议传递给TCP传输层。 TLS/SSL协议三大核心步骤：认证，密钥协商，数据加密。 在HTTPS协议中，客户端和服务端双方是互相不认识得，客户端可以是世界上任何一台机器得浏览器，必须采用动态密钥分配方式，这个时候密钥协商算法就出场了。 在公开密钥算法中，所有的网络通信都会存在中间人攻击，在https中必须引入PKI技术解决身份验证的问题，PKI的核心技术就是证书。PKI技术能够确保客户端接收到的服务器公钥确实是期待服务端的公钥。]]></content>
  </entry>
  <entry>
    <title><![CDATA[IdentityPro]]></title>
    <url>%2F2019%2F08%2F24%2FIdentityPro%2F</url>
    <content type="text"><![CDATA[1.添加必要的引用Microsoft.AspNetCore.IdentityPomelo.EntityFrameworkCore.MySql2.生成aspnetcore identity数据库]]></content>
  </entry>
  <entry>
    <title><![CDATA[文件流]]></title>
    <url>%2F2019%2F08%2F06%2F%E6%96%87%E4%BB%B6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[文件 文件是存储在具有特定名称和目录路径的磁盘中的数据的集合。当文件打开以进行读取或写入时，它将成为流。 流基本上是通过通信路径的字节序列。有两个主要流：输入流和输出流。输入流用于从文件读取数据(读取操作)，输出流用于写入文件(写入操作)。 FileStream12345678910111213// 写入FileStream f = new FileStream("e:\\filestream-demo.txt", FileMode.OpenOrCreate);//creating file stream f.WriteByte(65);//writing byte into stream f.Close();//closing stream// 读取FileStream f = new FileStream("e:\\filestream-demo.txt", FileMode.OpenOrCreate);int i = 0; while ((i = f.ReadByte()) != -1) &#123; Console.Write((char)i); &#125; f.Close(); StreamReader1234567891011121314151617181920// 一行一行读取FileStream f = new FileStream("e:\\myoutput.txt", FileMode.OpenOrCreate);StreamReader s = new StreamReader(f);string line = s.ReadLine();Console.WriteLine(line);string line2 = s.ReadLine();Console.WriteLine(line2);s.Close();f.Close();// 读取所有FileStream f = new FileStream("e:\\myoutput.txt", FileMode.OpenOrCreate);StreamReader s = new StreamReader(f);string line = "";while ((line = s.ReadLine()) != null)&#123; Console.WriteLine(line);&#125;s.Close();f.Close(); 大文本拷贝123456789101112131415161718192021222324252627282930313233private static void CopyFile(string source, string target) &#123; //创建一个读文件的流 using (FileStream fsread = new FileStream(source, FileMode.Open)) &#123; //创建一个写文件流 using (FileStream fswrite = new FileStream(target, FileMode.Create)) &#123; //创建一个读取文件、写入文件的一个缓冲区 //设置缓冲区大小，每次读取内容放到缓冲区中 byte[] buffer = new byte[1024 * 1024 * 10];//10MB long len = fsread.Length; //开始读取 while (true) &#123; //r 表示本次读到的字节数 int r = fsread.Read(buffer, 0, buffer.Length); if (r &lt;= 0) //已经到了文件末尾 &#123; break; &#125; else //读到了内容 &#123; fswrite.Write(buffer, 0, r); long allong = fswrite.Length; //已经拷贝的长度 double proc = (double)allong / len; Console.WriteLine("复制进度：" + proc + "%"); &#125; &#125; &#125; &#125; &#125; https://www.yiibai.com/csharp/c-sharp-stringreader.html]]></content>
      <categories>
        <category>DotNet</category>
      </categories>
      <tags>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css属性]]></title>
    <url>%2F2019%2F08%2F06%2FCss%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[行内元素和块级元素 行内元素会在一条直线上排列（默认宽度只与内容有关），都是同一行的，水平方向排列。 块级元素各占据一行（默认宽度是它本身父容器的100%（和父元素的宽度一致），与内容无关），垂直方向排列。块级元素从新行开始，结束接着一个断行。 块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素，只能包含文本或者其它行内元素。 行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效 行内元素和块级元素转换 display:block; (字面意思表现形式设为块级元素) display:inline; (字面意思表现形式设为行内元素) inline-block 的元素（如input、img)既具有 block 元素可以设置宽高的特性，同时又具有 inline 元素默认不换行的特性。当然不仅仅是这些特性，比如 inline-block 元素也可以设置 vertical-align（因为这个垂直对齐属性只对设置了inline-block的元素有效） 属性。HTML 中的换行符、空格符、制表符等合并为空白符，字体大小不为 0 的情况下，空白符自然占据一定的宽度，使用inline-block 会产生元素间的空隙。 行内元素和块级元素区别]]></content>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode-Debugger]]></title>
    <url>%2F2019%2F08%2F03%2FVSCode-Debugger%2F</url>
    <content type="text"><![CDATA[VSCode 调试 新建一个dotnet mvc项目 项目中添加 Microsoft.DotNet.Watcher.Tools 引用 VSCode添加c#插件 添加附件到进程调试配置文件 1234567891011121314&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ &#123; "name": "附加到进程", "type": "coreclr", "request": "attach", "processId": "$&#123;command:pickProcess&#125;" &#125; ]&#125; 在控制台运行dotnet watch run]]></content>
      <categories>
        <category>DotNet</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql-Beginner]]></title>
    <url>%2F2019%2F07%2F29%2FMysql-Beginner%2F</url>
    <content type="text"><![CDATA[函数 字符转日期 12345678910111213141516171819# 日期2019-08-08 -&gt; 20190808 CAST(CURRENT_DATE() AS SIGNED)# 时间 00:08:15 -&gt; 815CAST(CURRENT_TIME() AS SIGEND)# 时间戳 2019-08-08 00:08:15CAST(NOW() AS SIGNED)# 日期 2019-08-08 -&gt; 2020YEAR(CURRENT_DATE())# 00:08:15 -&gt; 15SECOND(CURRENT_DATE())# 时间转unix时间错UNIX_TIMESTAMP(NOW())# 字符串转时间CAST('2019-08-08' AS DATE)# 字符串转日期DATE_FROMAT(CURRENT_DATE(),'%Y-%m-%d')# 获取日期DAYNAME(CURRENT_DATE())MONTH(CURRENT_DATE()) 聚合函数(常用于GROUP BY从句的SELECT查询中) AVG(col) 返回指定列的平均值 COUNT(col) 返回指定列中非NULL值的个数 MIN(col) 返回指定列的最小值 MAX(col) 返回指定列的最大值 SUM(col) 返回指定列的所有值之和 GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果 字符串函数 CONCAT(s1,s2…,sn) 将s1,s2…,sn连接成字符串 CONCAT_WS(sep,s1,s2…,sn) 将s1,s2…,sn连接成字符串，并用sep字符间隔 LEFT(str,x) 返回字符串str中最左边的x个字符 RIGHT(str,x) 返回字符串str中最右边的x个字符 控制流函数 CASE WHEN[test1] THEN [result1]…ELSE [default] END 如果testN是真，则返回resultN，否则返回default CASE [test] WHEN[val1] THEN [result]…ELSE [default] END 如果test和valN相等，则返回resultN，否则返回default IF(test,t,f) 如果test是真，返回t；否则返回 f IFNULL(arg1,arg2) 如果arg1不是空，返回arg1，否则返回arg2 NULLIF(arg1,arg2) 如果arg1=arg2返回NULL；否则返回arg1]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Consul]]></title>
    <url>%2F2019%2F07%2F21%2FConsul%2F</url>
    <content type="text"><![CDATA[Consul Consul包含多个组件,但是作为一个整体,为你的基础设施提供服务发现和服务配置的工具。 服务发现：Consul的客户端可提供一个服务，比如api或者mysql，另外一些客户端可使用Consul去发现一个指定的服务提供者，通过DNS或者Http应用程序很容易找到他依赖的服务。 健康检查：Consul客户端可提供任意数量的健康检查，指定一个服务（比如一个api是否返回了200）或者使用本地节点（比如内存是否大于90%），这个信息可由opreator用来监视集群的健康，被服务发现组件用来避免将流量发送到不健康的主机。 Key/Value存储：应用程序可根据自己需要使用的Consul的层级的Key/Value存储，比如动态配置，功能标记，协调，领袖选举等。 多数据中心：Consul支持开箱即用的多数据中心，这意味着用户不需要担心建立额外的抽象层让业务扩展到多个区域，Consul面对DevOps和应用开发者友好，是他适合现代弹性的基础设置。 Consul使用场景 Docker 实例的注册与配置共享。 Coreos 实例的注册与配置共享。 SaaS 应用的配置共享、服务发现和健康检查。 vitess 集群。 与 confd 服务集成，动态生成 nginx 和 haproxy 配置文件。 Consul优势 市面现在有很多类似的软件比如：zookeeper 、Etcd、doozerd、eureka，Consul 相比这些软件有什么优势呢？ 使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言, zookeeper 采用的是 Paxos, 而 etcd 使用的则是 Raft。 支持 多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障，而其部署则需要考虑网络延迟，分片等情况等. zookeeper 和 etcd 均不提供多数据中心功能的支持。 支持 健康检查。 etcd 不提供此功能。 支持 HTTP、DNS 和 GPRS 协议接口。 zookeeper 的集成较为复杂，etcd 只支持 http 协议。 官方提供 WEB管理界面，etcd 无此功能。 Glossary Client：表示 Consul 客户端模式，是 Consul 节点的一种模式，所有注册到 Client 节点的服务会被转发到 Server 。本身无状态不持久化如何数据。Client 通过 HTTP、DNS、GRPC 接口请求转发给局域网内的服务端集群。 Server：表示 Consul 的服务端模式， Server 功能和 Client 都一样，不同的是 Server 持久化数据到本地。在局域网内与本地 Client 通讯，通过广域网与其他数据中心通讯。每个数据中心的 Server 数量推荐为 3 个或是 5 个。 Server-Leader ：表示这个 Server 是它们的老大，它和其它 Server 不一样的一点是，它需要负责同步注册的信息给其它的 Server 节点，同时也要负责各个节点的健康监测。如果 Leader 宕机了，通数据中心的所有 Server 内部会使用 Raft 算法来在其中选取一个 Leader 出来。 Agent ：Agent 是 Consul 的核心进程，Agent 的工作是维护成员关系信息、注册服务、健康检查、响应查询等等。Consul 集群的每一个节点都必须运行 agent 进程。 Consul的工作原理 使用微服务架构。传统的单体架构不够灵活不能很好的适应变化，从而向微服务架构进行转换，而伴随着大量服务的出现，管理运维十分不便，于是开始搞一些自动化的策略，服务发现应运而生。但是引入服务发现就可能引入一些技术栈，增加系统总体的复杂度。 在服务器Server1、Server2、Server3上分别部署了Consul Server，假设他们选举了Server2上的Consul Server节点为Leader. 在服务器Server4和Server5上通过Consul Client分别注册Service A、B、C。服务注册到Consul可以通过HTTP API（8500端口）的方式，也可以通过Consul配置文件的方式。Consul Client可以认为是无状态的，它将注册信息通过RPC转发到Consul Server，服务信息保存在Server的各个节点中，并且通过Raft实现了强一致性。 在服务器Server6中Program D需要访问Service B，这时候Program D首先访问本机Consul Client提供的HTTP API，本机Client会将请求转发到Consul Server，Consul Server查询到Service B当前的信息返回，最终Program D拿到了Service B的所有部署的IP和端口，然后就可以选择Service B的其中一个部署并向其发起请求了。如果服务发现采用的是DNS方式，则Program D中直接使用Service B的服务发现域名，域名解析请求首先到达本机DNS代理，然后转发到本机Consul Client，本机Client会将请求转发到Consul Server，Consul Server查询到Service B当前的信息返回，最终Program D拿到了Service B的某个部署的IP和端口。 http://blog.didispace.com/consul-service-discovery-exp 参数说明 advertise：通知展现地址用来改变我们给集群中的其他节点展现的地址，一般情况下-bind地址就是展现地址。 bootstrap： 用来控制一个server是否在bootstrap模式，在一个datacenter中只能有一个server处于bootstrap模式，当一个server处于bootstrap模式时，可以自己选举为raft leader。 bootstrap-expect：在一个datacenter中期望提供的server节点数目，当该值提供的时候，consul一直等到达到指定sever数目的时候才会引导整个集群，该标记不能和bootstrap共用。 bind：该地址用来在集群内部的通讯IP地址，集群内的所有节点到地址都必须是可达的，默认是0.0.0.0。 client：consul绑定在哪个client地址上，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1。 config-file：明确的指定要加载哪个配置文件。 config-dir：配置文件目录，里面所有以.json结尾的文件都会被加载。 data-dir：提供一个目录用来存放agent的状态，所有的agent允许都需要该目录，该目录必须是稳定的，系统重启后都继续存在。 dc:该标记控制agent允许的datacenter的名称，默认是dc1。 encrypt： 指定secret key，使consul在通讯时进行加密，key可以通过consul keygen生成，同一个集群中的节点必须使用相同的key。 join：加入一个已经启动的agent的ip地址，可以多次指定多个agent的地址。如果consul不能加入任何指定的地址中，则agent会启动失败，默认agent启动时不会加入任何节点。 retry-interval：两次join之间的时间间隔，默认是30s。 retry-max：尝试重复join的次数，默认是0，也就是无限次尝试。 log-level：consul agent启动后显示的日志信息级别。默认是info，可选：trace、debug、info、warn、err。 node：节点在集群中的名称，在一个集群中必须是唯一的，默认是该节点的主机名。 protocol：consul使用的协议版本。 rejoin：使consul忽略先前的离开，在再次启动后仍旧尝试加入集群中。 server：定义agent运行在server模式，每个集群至少有一个server，建议每个集群的server不要超过5个。 syslog：开启系统日志功能，只在linux/osx上生效。 pid-file：提供一个路径来存放pid文件，可以使用该文件进行SIGINT/SIGHUP(关闭/更新)agent。 1234567891011121314151617# 启动Consul和web管理docker run -d -p 8001:8500 --name consulserver-01 consul agent -server -bootstrap -ui -node=Node-01 -client='0.0.0.0' -data-dir ~/consul/data -config-dir ~/consul/configdocker run -d --name consulserver-02 consul agent -server -bootstrap -ui -node=Node-02 -client='0.0.0.0' -data-dir /var/vdb1/wangjun/consul/data -config-dir /var/vdb1/wangjun/consul/config -join='172.17.0.2'docker run -d --name consulserver-03 consul agent -server -bootstrap -ui -node=Node-03 -client='0.0.0.0' -data-dir /var/vdb1/wangjun/consul/data -config-dir /var/vdb1/wangjun/consul/config -join='172.17.0.2'docker run -d --name consulclient-01 consul agent -client -bootstrap -ui -node=Node-client-01 -client='0.0.0.0' -data-dir /var/vdb1/wangjun/consul/data -config-dir /var/vdb1/wangjun/consul/config -join='172.17.0.2'# 查看consul信息docker exec consul_server_1 consul members#Node Address Status Type Build Protocol DC Segment#1 172.17.0.2:8301 alive server 1.5.2 2 dc1 &lt;all&gt;#通过命令获取到引导 Consul 的 Ip 地址 172.17.0.2 #加入到集群， 命名为 -node=2 、-node=3 docker run -d --name=consul_server_2 consul agent -server -bootstrap -ui -node=2 -client='0.0.0.0' -join='172.17.0.2' docker run -d --name=consul_server_3 consul agent -server -bootstrap -ui -node=3 -client='0.0.0.0' -join='172.17.0.2' # 添加Client docker run -d --name=consul_server_4 consul agent -client -node=4 -join='172.17.0.2' -client='0.0.0.0' # Client需要集群继续添加node5，6就好]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Consul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Async-Await]]></title>
    <url>%2F2019%2F07%2F21%2FAsync-Await%2F</url>
    <content type="text"><![CDATA[Task对象的前世今生 Task对象是.Net Framework 4.0之后出现的异步编程的一个重要对象。在一定程度上来说，Task对象可以理解Thread对象的一个升级产品。 示例 12345678910111213141516171819class Program&#123; static void Main(string[] args) &#123; Console.WriteLine("执行方法之前的时间：" + DateTime.Now.ToString("yyyy-MM-dd hh:MM:sss")); var result = Task.Run(() =&gt;&#123;return GetResult();&#125;); Console.WriteLine("主线程Id:" + Thread.CurrentThread.ManagedThreadId); Console.WriteLine(result.Result); Console.WriteLine("执行方法之后的时间：" + DateTime.Now.ToString("yyyy-MM-dd hh:MM:sss")); Console.ReadKey(); &#125; public static string GetResult() &#123; Thread.Sleep(2000); Console.WriteLine("GetResult的线程Id:" + Thread.CurrentThread.ManagedThreadId); return "WangJunZzz"; &#125;&#125; 结果 123456789#执行方法之前的时间：2019-07-21 01:07:42#WangJunZzz#执行方法之后的时间：2019-07-21 01:07:44#PS E:\Code\async\async-await&gt; dotnet run#执行方法之前的时间：2019-07-21 01:07:52#主线程Id:1#GetResult的线程Id:3#WangJunZzz#执行方法之后的时间：2019-07-21 01:07:54 从结果分析得知，var result = Task.Run(() =&gt;{return GetResult();});这一句后，主线程并没有阻塞取执行GetResult()方法，而是开启一个线程取执行GetResult()方法。知道执行result.Result这一句的时候才会等待GetResult()方法执行完毕。由此可知，Task.Run(()=&gt;{}).Reslut是阻塞主线程的，主要因为主线程要得到返回值，必须等方法执行完毕。 线程不安全 示例 12345678910111213141516171819class Program&#123; private static bool isDone = false; static void Main(string[] args) &#123; new Thread(Done).Start(); new Thread(Done).Start(); Console.ReadKey(); &#125; static void Done() &#123; if (!isDone) &#123; Console.WriteLine("Done"); isDone = true; &#125; &#125;&#125; 结果 12#Done#Done 第一个线程还没有来得及把isDone设置成true，第二个线程就进来了，而这不是我们想要的结果，在多个线程下，结果不是我们的预期结果，这就是线程不安全。 锁 示例1234567891011121314151617181920212223class Program&#123; private static bool isDone = false; private static object mylock = new object(); static void Main(string[] args) &#123; new Thread(Done).Start(); new Thread(Done).Start(); Console.ReadKey(); &#125; static void Done() &#123; lock(mylock) &#123; if (!isDone) &#123; Console.WriteLine("Done"); isDone = true; &#125; &#125; &#125;&#125; 加上锁之后，被锁住的代码在同一个时间内只允许一个线程访问，其它的线程会被阻塞，只有等到这个锁被释放之后其它的线程才能执行被锁住的代码。 Async,Await 使用它们，方法的返回类型应为Task类型。为了使用await关键字，您必须在方法定义中使用async。如果你在方法定义中放入async，你应该在主体方法的某个地方至少有一处await关键字，如果你缺少他，你通常会收到Visual Studio的一个警告。 await 之后不会开启新的线程(await 从来不会开启新的线程)。 加上await关键字之后，后面的代码会被挂起等待，直到task执行完毕有返回值的时候才会继续向下执行，这一段时间主线程会处于挂起状态。 Task.Run(()=&gt;{}); 将一个任务添加到线程池里，排队执行。 async 标识一个方法为异步方法，可以与主线程并行执行，发挥CPU的多核优势。 await 在调用一个async方法前可以添加这个修饰符，它意思是等待当前异步方法执行完后，再执行下面的代码。 ConfigureAwait(true)，代码由同步执行进入异步执行时，当前线程上下文信息就会被捕获并保存至 SynchronizationContext中，供异步执行中使用，并且供异步执行完成之后的同步执行中使用。 Configurewait(flase)，不进行线程上下文信息的捕获，async方法中与await之后的代码执行时就无法获取await之前的线程的上下文信息，在ASP.NET中最直接的影响就是HttpConext.Current的值为null，但不会出现非空引用的错误。 async配合Task是为了简化异步调用，异步调用的目的恰恰就是为了释放线程资源。 在await的时候，线程就被释放了，等到异步操作完成才会回头来继续执行后面的代码。async的用途恰恰就在于避免阻塞，写的代码看起来像是同步的阻塞代码，但编译后不是，这才是async的精髓。(https://www.cnblogs.com/jesse2013/p/async-and-await.html 评论)。 在.NetCore中我们不用继续关心异步同步混用情况下，是否哪里没有设置ConfigureAwait(false) 会导致的死锁问题，因为在.netcore中的async/await 可能在任何线程上执行，并且可能并行运行！。]]></content>
      <categories>
        <category>DotNet</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus]]></title>
    <url>%2F2019%2F07%2F09%2FEventBus%2F</url>
    <content type="text"><![CDATA[引言 事件总线这个概念对你来说可能很陌生，但提到观察者（发布-订阅）模式，你也许就很熟悉。事件总线是对发布-订阅模式的一种实现。它是一种集中式事件处理机制，允许不同的组件之间进行彼此通信而又不需要相互依赖，达到一种解耦的目的。 本质：事件是由事件源和事件处理组成。 发布订阅模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 ——发布订阅模式。 基本思路 在事件总线内部维护着一个事件与事件处理程序相映射的字典。 利用反射，事件总线会将实现了IEventHandler的处理程序与相应事件关联到一起，相当于实现了事件处理程序对事件的订阅。 当发布事件时，事件总线会从字典中找出相应的事件处理程序，然后利用反射去调用事件处理程序中的方法。 基于内存事件总线实现 定义一个事件接口 123public interface IEvent&#123;&#125; 定义一个事件处理接口 1234public interface IEventHandler : IEvent&#123; Task Handle(IEvent e);&#125; 定义一个发布接口 1234public interface IEventSubscriber &#123; Task Subscribe&lt;TEvent, EH&gt;() where TEvent : IEvent where EH : class, IEventHandler, new();&#125; 创建一个类用来存事件 1234public static class MemoryMq&#123; public static ConcurrentDictionary&lt;string, IEvent&gt; eventQueueDict &#123; get; set; &#125;&#125; 实现发布类 12345678910111213public class InMemoryEventPublisher : IEventPublisher&#123; public Task Publish&lt;TEvent&gt;(TEvent e) where TEvent : IEvent &#123; if (e == null) return Task.CompletedTask; if (MemoryMq.eventQueueDict == null) &#123; MemoryMq.eventQueueDict = new ConcurrentDictionary&lt;string, IEvent&gt;(); &#125; MemoryMq.eventQueueDict.GetOrAdd(Guid.NewGuid().ToString(), e); return Task.CompletedTask; &#125;&#125; 实现订阅类 1234567891011121314151617181920212223public class InMemoryEventSubscriber : IEventSubscriber&#123; public Task Subscribe&lt;TEvent, EH&gt;() where TEvent : IEvent where EH : class, IEventHandler, new() &#123; EH state = new EH(); Task.Run(() =&gt; &#123; while (true) &#123; if (MemoryMq.eventQueueDict != null) &#123; foreach (var item in MemoryMq.eventQueueDict) &#123; state.Handle(item.Value as IEvent); IEvent o; MemoryMq.eventQueueDict.TryRemove(item.Key, out o); &#125; &#125; &#125; &#125;); return Task.CompletedTask; &#125; 实现逻辑处理 123456789101112131415161718public class EventHandler : IEventHandler&#123; public Task Handle(IEvent e) &#123; switch (e) &#123; case Order value: Console.WriteLine(value.Name); break; &#125; return Task.CompletedTask; &#125;&#125; public class Order : IEvent &#123; public string name &#123; get; set; &#125; &#125; 测试 1234567891011121314class Program&#123; static void Main(string[] args) &#123; var pub = new InMemoryEventPublisher(); var sub = new InMemoryEventSubscriber(); sub.Subscribe&lt;Order, EventHandler&gt;(); var order = new Order(); order.Name = "wangjunzzz"; pub.Publish(order); Console.WriteLine("Hello World!"); Console.ReadKey(); &#125;&#125;]]></content>
      <categories>
        <category>DotNet</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMq]]></title>
    <url>%2F2019%2F06%2F27%2FRabbitMq%2F</url>
    <content type="text"><![CDATA[消息中间件 消息中间件是指利用高效可靠得消息传递机制进行与平台数据无关的数据交流，并基于数据通信来进行分布式系统集成。 RabbitMq整体上是一个生产者和消费者模型，主要负责接收，存储和转发消息。 RabbitMq就是AMQP(应用层高级消息队列协议)协议的Erlang的实现。 作用 解耦：独立修改或者扩展两边的处理过程，只要确保遵循相同的接口约束即可。 削峰：使用中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩溃。 异步通信：很多时候不想立即处理消息，中间件允许把消息放到中间件中，但是不立即处理它，之后需要的时候在慢慢处理。 名词解释 生产者：投递消息的一方. 消费者: 接收消息的一方. Broker：消息中间件的服务节点. Queue: 队列，RabbitMq的内部对象. 交换器：生产者把消息发送到Exchange（交换器）,由交换器把消息路由到一个或者多个队列中,如果路由不到,或许会返回给生产者,或许会直接丢弃.RabbitMq有四种交换机类型:交换机类型 五种模式 简单模式：一个生产者，一个消费者. 简单模式特点，其实就是是生成者直接将消息发送给队列，消费者直接从队列取消息，中间没有其他的东西，并且1对1的。 生产者 123456789101112131415161718192021222324252627282930//创建mq的连接工厂var factory = new ConnectionFactory();factory.HostName = "119.29.225.20";factory.UserName = "userId";factory.Password = "pwd";//创建一个连接var connection = factory.CreateConnection();//创建一个频道var channel = connection.CreateModel();//创建一个队列// durable:持久化可以把交换器存盘，在服务器重启的时候不会丢失相关信息.// exclusive:如果申明为排它队列,该队列仅对首次申明它的连接可见,并且在连接断开的时候自动删除,// autoDelete:是否自动删除,自动删除的前提是：至少又一个消费者连接到这个队列,// 之后所有与这个队列连接的消费者都断开时,才会自动删除.channel.QueueDeclare(queue: "hello", durable: false, exclusive: false, autoDelete: false, arguments: null);for (int i = 0; i &lt; 50; i++)&#123; string message = "Hello World!"+i; var body = Encoding.UTF8.GetBytes(message) // 发送消息 channel.BasicPublish(exchange: "", routingKey: "hello", basicProperties: null, body: body); Console.WriteLine(" [x] Sent &#123;0&#125;", message);&#125; 消费者 1234567891011121314151617181920212223242526var factory = new ConnectionFactory();factory.HostName = "119.29.225.20";factory.UserName = "userId";factory.Password = "pwd";using (var connection = factory.CreateConnection())&#123; using (var channel = connection.CreateModel()) &#123; channel.QueueDeclare(queue: "hello", durable: false, exclusive: false, autoDelete: false, arguments: null); var consumer = new EventingBasicConsumer(channel); consumer.Received += (model, ea) =&gt; &#123; var body = ea.Body; var message = Encoding.UTF8.GetString(body); Console.WriteLine(" [x] Received &#123;0&#125;", message); &#125;; channel.BasicConsume(queue: "hello", autoAck: true, consumer: consumer); Console.ReadKey(); &#125;&#125; 工作模式：一个生产者,多个消费者. 消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2,同时监听同一个队列,消息被消费?C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患,高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(syncronize,与同步锁的性能不一样) 保证一条消息只能被一个消费者使用).一条消息只会被一个消费者接收；rabbit采用轮询的方式将消息是平均发送给消费者的；消费者在处理完某条消息后，才会收到下一条消息. 12]]></content>
      <categories>
        <category>Plugs/RabbitMq</category>
      </categories>
      <tags>
        <tag>RabbitMq</tag>
      </tags>
  </entry>
</search>
